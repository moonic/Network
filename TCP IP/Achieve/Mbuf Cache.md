# Mbuf cache 
> m b u f的主要用途是保存在进程和网络接口间互相传递的用户数据。但 m b u f也用于保存其
他各种数据：源与目标地址、插口选项等等。


1) 如果m _ f l a g s等于0，m b u f只包含数据。在m b u f中有1 0 8字节的数据空间(m _ d a t数组)。
指针m _ d a t a指向这1 0 8字节缓存中的某个位置。我们所示的 m _ d a t a指向缓存的起始，
但它能指向缓存中的任意位置。成员 m _ l e n指示了从m _ d a t a开始的数据的字节数。
图1 - 6是这类m b u f的一个例子。
在图2 - 1中，结构m _ h d r中有六个成员，它的总长是 2 0字节。当我们查看此结构的 C语
言定义时，会看见前四个成员每个占用 4字节而后两个成员每个占用 2字节。在图2 - 1中
我们没有区分4字节成员和2字节成员。
2) 第二类m b u f的m _ f l a g s值是M _ P K T H D R，它指示这是一个分组首部，描述一个分组数
据的第一个m b u f。数据仍然保存在这个 m b u f中，但是由于分组首部占用了 8字节，只
有1 0 0字节的数据可存储在这个 m b u f中(在m _ p k t d a t数组中)。图1 - 1 0是这种m b u f的一
个例子。
成员m _ p k t h d r . l e n的值是这个分组的 m b u f链表中所有数据的总长度：即所有通过
m _ n e x t指针链接的 m b u f的m _ l e n值的和，如图 1 - 8所示。输出分组没有使用成员
m _ p k t h d r . r c v i f，但对于接收的分组，它包含一个指向接收接口 i f n e t结构(图3 -
6 )的指针。
3) 下一种m b u f不包含分组首部(没有设置K _ P K T H D R)，但包含超过2 0 8字节的数据，这时
用到一个叫“簇”的外部缓存 (设置M _ E X T)。在此m b u f中仍然为分组首部结构分配了
空间，但没有用 — 在图2 - 1中，我们用阴影显示出来。 N e t / 3分配一个大小为 1 0 2 4或
2 0 4 8字节的簇，而不是使用多个 m b u f来保存数据(第一个带有1 0 0字节数据，其余的每
个带有1 0 8字节数据)。在这个m b u f中，指针m _ d a t a指向这个簇中的某个位置。
N e t / 3版本支持七种不同的结构。定义了四种 1 0 2 4字节的簇(惯例值)，三种2 0 4 8字节的
如果簇的大小是 2 0 4 8，对于以太网
分组(最大1 5 0 0字节)，每个簇大约有四分之一没有用。在 2 7 . 5节中我们会看到 N e t / 3
T C P发送的每个 T C P报文段从来不超过一簇大小，因为当簇的大小为 1 0 2 4时，每个
1 5 0 0字节的以太网帧几乎三分之一未用。但是 [Mogul 1993，图1 5 - 1 5 ]显示了当在以太
网中发送最大帧而不是 1 0 2 4字节的帧时能明显提高以太网的性能。这就是一种性能 /存
储器互换。老的系统使用 1 0 2 4字节簇来节约存储器，而拥有廉价存储器的新系统用
2 0 4 8字节的簇来提高性能。在本书中我们假定一簇的大小是 2 0 4 8字节。


簇 ( c l u s t e r )”用过不同的名字。常量 M C L B Y T E S是这些
缓存( 1 0 2 4或2 0 4 8 )的大小，操作这些缓存的宏的名字是 M C L G E T、M C L A L L O C和
M C L F R E E。这就是为什么称它们为“簇”的原因。但我们还看到 m b u f的标志是
M _ E X T，它代表“外部的”缓存。最后， [ L e ffler et al. 1989]称它们为映射页( m a p p e d
p a g e )。这后一种称法来源于它们的实现，在 2 . 9节我们会看到当要求一个副本时，这
些簇是可以共享的
4) 最后一类 m b u f包含一个分组首部，并包含超过 2 0 8字节的数据。同时设置了标志
M _ P K T H D R和M _ E X T。
对于图2 - 1，我们还有另外几点需要说明：
• m b u f结构的大小总是 1 2 8字节。这意味着图 2 - 1右边两个m b u f在结构m _ e x t后面的未用
空间为8 8字节( 1 2 8-2 0-8-1 2 )。
• 既然有些协议(例如U D P )允许零长记录，当然就可以有m _ l e n为0的数据缓存。
• 在每个m b u f中的成员m _ d a t a指向相应缓存的开始( m b u f缓存本身或一个簇)。这个指针
能指向相应缓存的任意位置，不一定是起始。

带有簇的m b u f总是包含缓存的起始地址(m _ e x t . e x t _ b u f)和它的大小(m _ e x t . e x t _ s i z e)。
我们在本书采用的大小为2 0 4 8。成员m _ d a t a和m _ e x t . e x t _ b u f值是不同的(如我们所
示)，除非m _ d a t a也指向缓存的第一个字节。结构 m _ e x t的第三个成员 e x t _ f r e e，
N e t / 3当前未用。
• 指针m _ n e x t把m b u f链接在一起，把一个分组(记录)形成一条m b u f链表，如图1 - 8所示。
• 指针m _ n e x t p k t把多个分组(记录)链接成一个m b u f链表队列。在队列中的每个分组可
以是一个单独的m b u f，也可以是一个m b u f链表。每个分组的第一个 m b u f包含一个分组
首部。如果多个m b u f定义一个分组，只有第一个 m b u f的成员m _ n e x t p k t被使用 — 链
表中其他m b u f的成员m _ n e x t p k t全是空指针。
带有U D P数据报分组首部的第一个 m b u f的类型是M T _ D A T A，但带有T C P报文段
分组首部的第一个m b u f的类型是M T _ H E A D E R。这是由于U D P和T C P采用了不同的方
式往数据中添加首部造成的，但没有什么不同。这两种类型的 m b u f本质上一样。链
表中第一个m b u f的m _ f l a g s的值M _ P K T H D R指示了它是一个分组首部。
仔细的读者可能会注意到我们显示一个 m b u f的图(Net/3 mbuf，图2 - 1 )与显示一个
Net/1 mbuf的图[ L e ffler et al. 1989，p . 2 9 0 ]的区别。这个变化是在N e t / 2中造成的：添
加了成员 m _ f l a g s，把指针 m _ a c t改名为m _ n e x t p k t，并把这个指针移到这个
m b u f的前面。

* 简单的m b u f宏和函数
超过两打的宏和函数来处理 m b u f (分配一个m b u f，释放一个m b u f，等等)。让我们来查
看几个宏与函数的源代码，看看它们是如何实现的。
有些操作既提供了宏也提供了函数。宏版本的名称是以 M开头的大写字母名称，而函数是
以m _开始的小写字母名称。两者的区别是一种典型的时间 -空间互换。宏版本在每个被用到的
地方都被C预处理器展开(要求更多的代码空间)，但是它在执行时更快，因为它不需要执行函
数调用(对于有些体系结构，这是费时的 )。而对于函数版本，它在每个被调用的地方变成了一
些指令(参数压栈，调用函数等)，要求较少的代码空间，但会花费更多的执行时间。



 
