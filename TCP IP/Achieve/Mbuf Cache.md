# Mbuf cache 
> m b u f的主要用途是保存在进程和网络接口间互相传递的用户数据但mbuf也用于保存其他各种数据：源与目标地址、插口选项等等。

* 四种mbuf 
  1. 如果m_flags等于0，m b u f只包含数据,mbuf中有108字节的数据空间(m_dat数组)指针m_data指向这108字节缓存中的某个位置。m_d ata指向缓存的起始，但它能指向缓存中的任意位置成员m_len指示了从m_data开始的数据的字节数。
结构m_hdr中有六个成员，它的总长是 2 0字节。当我们查看此结构的 C语言定义时，会看见前四个成员每个占用 4字节而后两个成员每个占用 2字节。
  2. 第二类m b u f的m_flags值是M_PKTHDR，它指示这是一个分组首部，描述一个分组数据的第一个m b u f。数据仍然保存在这个 m b u f中，但是由于分组首部占用了 8字节，只有1 0 0字节的数据可存储在这个 m b u f中(在m _ p k t d a t数组中)。图m b u f的一个例子。成员m _ p k t h d r . l e n的值是这个分组的 m b u f链表中所有数据的总长度：即所有通过m_next指针链接的 m b u f的m _ l e n值的和输出分组没有使用成员m_pkthdr.rcvif，但对于接收的分组，它包含一个指向接收接口 i f n e t结构指针。
  3. 下一种m b u f不包含分组首部(没有设置K_PKTHDR)，但包含超过2 0 8字节的数据，这时用到一个叫“簇”的外部缓存 (设置M _ E X T)。在此m buf中仍然为分组首部结构分配了空间，但没有用 — 在图2 - 1中，我们用阴影显示出来。 N e t / 3分配一个大小为 1 0 2 4或2048字节的簇，而不是使用多个 m b u f来保存数据(第一个带有1 0 0字节数据，其余的每个带有1 0 8字节数据)。在这个m b u f中，指针m _ d a t a指这簇中的某个位置。N e t / 3版本支持七种不同的结构。定义了四种 1 0 2 4字节的簇(惯例值)，三种2 0 4 8字节的如果簇的大小是 2 0 4 8，对于以太网分组(最大1 5 0 0字节)，每个簇大约有四分之一没有用在以太网中发送最大帧而不是 1 0 2 4字节的帧时能明显提高以太网的性能。这就是一种性能 /存储器互换。老的系统使用 1 0 2 4字节簇来节约存储器，而拥有廉价存储器的新系统用2 0 4 8字节的簇来提高性能。
  * 簇 (cluster)”用过不同的名字常量MCLBYTES是这些缓存( 1 0 2 4或2 0 4 8 )的大小，操作这些缓存的宏的名字是MCLGET、MCLALLOC和M C L F R E E。这就是为什么称它们为“簇”的原因。但我们还看到 m b u f的标志是M _ E X T，它代表“外部的”缓存。[ Leffleret al.1989]称它们为映射页(mappedpage)。实现簇是可以共享的
  4. 最后一类 m b u f包含一个分组首部，并包含超过208字节的数据。同时设置了标志M_PKTHDR和M_EXT
• m b u f结构的大小总是 1 2 8字节。这意味着图2-1右边两个m b u f在结构m _ e x t后面的未用
空间为8 8字节(12820812)。
• 既然有些协议(例如U D P )允许零长记录，可以有m_len为0的数据缓存。
• 在每个m b u f中的成员m _ d a t a指向相应缓存的开始( m b u f缓存本身或一个簇)。这个指针能指向相应缓存的任意位置，不一定是起始。
  * 带有簇的mbuf总是包含缓存的起始地址(m_ext.ext_buf)和它的大小(m _ e x t . e x t _ s i z e)大小为2 0 4 8。成员m_data和m_ext.ext_buf值是不同的(如我们所示)，除非m _ d a t a也指向缓存的第一个字节。结构 m _ e x t的第三个成员ext_freeNe t/3当前未用。
• 指针m _ n e x t把m b u f链接在一起，把一个分组(记录)形成一条m b u f链表，如图1 - 8所示。
• 指针m _ n e x t p k t把多个分组(记录)链接成一个m b u f链表队列。在队列中的每个分组可

* 以是一个单独的mbuf，也可以是一个mbuf链表。每个分组的第一个mbuf包含一个分组首部
* 如果多个mbuf定义一个分组，只有第一个mbuf的成员m _ n e x t p k t被使用 — 链表中其他mbuf的成员m_nextpkt全是空指针带UDP数据报分组首部的第一个mbuf的类型是MT_DATA，但带有TCP报文段分组首部的第一个mbuf的类型是MT_HEADER
* 由于UDP和TCP采用了不同的方式往数据中添加首部造成的，但没有什么不同。这两种类型的mbuf本质上一样。链表中第一个mbuf的m_flags的值M_PKTHDR指示了它是一个分组首部。

## 简单的m b u f宏和函数
 
* m _ g e t函数
```c++
struct mbuf *
m_get(noeait ,type)
int nowait,type'
{
  struct mbuf *m;
  MGET(m,nowait,type)
  return(m);
}
```
调用表明参数n o w a i t的值为M _ W A I T或M _ D O N T W A I T，它取决于在存储器不可用时
是否要求等待。例如，当插口层请求分配一个 m b u f来存储s e n d t o系统调用(图1 - 6 )的目标地
址时，它指定M _ W A I T，因为在此阻塞是没有问题的。但是当以太网设备驱动程序请求分配一
个m b u f来存储一个接收的帧时 (图1 - 1 0 )，它指定M _ D O N T W A I T，因为它是作为一个设备中断
处理来执行的，不能进入睡眠状态来等待一个 m b u f。在这种情况下，若存储器不可用，设备
驱动程序丢弃这个帧比较好

 
