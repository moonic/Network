# Mbuf cache 
> m b u f的主要用途是保存在进程和网络接口间互相传递的用户数据但mbuf也用于保存其他各种数据：源与目标地址、插口选项等等。

* 四种mbuf 
  1. 如果m_flags等于0，m b u f只包含数据,mbuf中有108字节的数据空间(m_dat数组)指针m_data指向这108字节缓存中的某个位置。m_d ata指向缓存的起始，但它能指向缓存中的任意位置成员m_len指示了从m_data开始的数据的字节数。
结构m_hdr中有六个成员，它的总长是 2 0字节。当我们查看此结构的 C语言定义时，会看见前四个成员每个占用 4字节而后两个成员每个占用 2字节。
  2. 第二类m b u f的m_flags值是M_PKTHDR，它指示这是一个分组首部，描述一个分组数据的第一个m b u f。数据仍然保存在这个 m b u f中，但是由于分组首部占用了 8字节，只有1 0 0字节的数据可存储在这个 m b u f中(在m _ p k t d a t数组中) 成员m _ p k t h d r . l e n的值是这个分组的 m b u f链表中所有数据的总长度：即所有通过m_next指针链接的 m b u f的m _ l e n值的和输出分组没有使用成员m_pkthdr.rcvif，但对于接收的分组，它包含一个指向接收接口 i f n e t结构指针。
  3. 下一种m b u f不包含分组首部(没有设置K_PKTHDR)，但包含超过2 0 8字节的数据，这时用到一个叫“簇”的外部缓存 (设置M _ E X T)。在此m buf中仍然为分组首部结构分配了空间 N e t / 3分配一个大小为 1 0 2 4或2048字节的簇，而不是使用多个 m b u f来保存数据(第一个带有1 0 0字节数据，其余的每个带有1 0 8字节数据)。在这个m b u f中，指针m _ d a t a指这簇中的某个位置。N e t / 3版本支持七种不同的结构。定义了四种 1 0 2 4字节的簇(惯例值)，三种2 0 4 8字节的如果簇的大小是 2 0 4 8，对于以太网分组(最大1 5 0 0字节)，每个簇大约有四分之一没有用在以太网中发送最大帧而不是 1 0 2 4字节的帧时能明显提高以太网的性能。这就是一种性能 /存储器互换。老的系统使用 1 0 2 4字节簇来节约存储器，而拥有廉价存储器的新系统用2 0 4 8字节的簇来提高性能。
  * 簇 (cluster)”用过不同的名字常量MCLBYTES是这些缓存( 1 0 2 4或2 0 4 8 )的大小，操作这些缓存的宏的名字是MCLGET、MCLALLOC和M C L F R E E。这就是为什么称它们为“簇”的原因。但我们还看到 m b u f的标志是M _ E X T，它代表“外部的”缓存。[ Leffleret al.1989]称它们为映射页(mappedpage)。实现簇是可以共享的
  4. 最后一类 m b u f包含一个分组首部，并包含超过208字节的数据。同时设置了标志M_PKTHDR和M_EXT
• m b u f结构的大小总是 1 2 8字节。这意味着图2-1右边两个m b u f在结构m _ e x t后面的未用
空间为8 8字节(12820812)。
• 既然有些协议(例如U D P )允许零长记录，可以有m_len为0的数据缓存。
• 在每个m b u f中的成员m _ d a t a指向相应缓存的开始( m b u f缓存本身或一个簇)。这个指针能指向相应缓存的任意位置，不一定是起始。
  * 带有簇的mbuf总是包含缓存的起始地址(m_ext.ext_buf)和它的大小(m _ e x t . e x t _ s i z e)大小为2 0 4 8。成员m_data和m_ext.ext_buf值是不同的(如我们所示)，除非m _ d a t a也指向缓存的第一个字节。结构 m _ e x t的第三个成员ext_freeNe t/3当前未用。
• 指针m _ n e x t把m b u f链接在一起，把一个分组(记录)形成一条m b u f链表，如图1 - 8所示。
• 指针m _ n e x t p k t把多个分组(记录)链接成一个m b u f链表队列。在队列中的每个分组可

* 以是一个单独的mbuf，也可以是一个mbuf链表。每个分组的第一个mbuf包含一个分组首部
* 如果多个mbuf定义一个分组，只有第一个mbuf的成员m _ n e x t p k t被使用 — 链表中其他mbuf的成员m_nextpkt全是空指针带UDP数据报分组首部的第一个mbuf的类型是MT_DATA，但带有TCP报文段分组首部的第一个mbuf的类型是MT_HEADER
* 由于UDP和TCP采用了不同的方式往数据中添加首部造成的，但没有什么不同。这两种类型的mbuf本质上一样。链表中第一个mbuf的m_flags的值M_PKTHDR指示了它是一个分组首部。

## 简单的m b u f宏和函数
 
* m _ g e t函数
```c++
struct mbuf *
m_get(noeait ,type)
int nowait,type'
{
  struct mbuf *m;
  MGET(m,nowait,type)
  return(m);
}
```
调用表明参数n o w a i t的值为M _ W A I T或M _ D O N T W A I T，它取决于在存储器不可用时
是否要求等待。例如，当插口层请求分配一个 m b u f来存储s e n d t o系统调用(图1 - 6 )的目标地
址时，它指定M _ W A I T，因为在此阻塞是没有问题的。但是当以太网设备驱动程序请求分配一
个m b u f来存储一个接收的帧时 (图1 - 1 0 )，它指定M _ D O N T W A I T，因为它是作为一个设备中断
处理来执行的，不能进入睡眠状态来等待一个 m b u f。在这种情况下，若存储器不可用，设备
驱动程序丢弃这个帧比较好

 
* M G E T宏
  * 用M G E T来分配存储s e n d t o系统调用的目标地址的mbut
MGET(m, M_WAIT, MT_SONAME);
if (m == NULL)
return(ENOBUFS);
  * M G E T一开始调用内核宏 M A L L O C，它是通用内核存储器分配器进行的。
  数组mbtypes把mbuf的MTxxx值转换成相应的M_xxx 值(若存储器被分配，成员m_type被设置为参数中的值。1 5 8 用于跟踪统计每种m b u f类型的内核结构加1 (m b s t a t)当执行这句时，宏MBUFLOCK把它作为参数来改变处理器优先级，然后把优先级恢复为原值。
  防止在执行语句mbstat.m_mtypes[type]++ 时被网络设备中断，因为m b u f可能在内核中的各层中被分配。考虑这样一
个系统，它用三步来实现一个C中的+ +运算：
( 1 )把当前值装入一个寄存器；
( 2 )寄存器加1；
( 3 )把寄存器值存入存储器。假设计数器值为7 7并且M G E T在插口层执行。假设执行了步骤1和2 (寄存器
值为7 8 )，并且一个设备中断发生。若设备驱动也执行M G E T来获得同种类型的m b u f，在存储器中
取值( 7 7 )，加1 ( 7 8 )，并存回在存储器。当被中断执行的M G E T的步骤3继续执行时，它将寄存器的
值( 7 8 )存入存储器。但是计数器应为7 9，而不是7 8，这样计数器就被破坏了。
159-160两个m b u f指针，m _ n e x t和m _ n e x t p k t，被设置为空指针。若必要，由调用者把
m b u f加入到一个链或队列最后，数据指针被设置为指向1 0 8字节的m b u f缓存的起始，而标志被设置为0。


* mbuf锁
  * 函数和宏并不调用 s p l函数，而是调用M B U F L O C K来保护这些函数和宏不被中断。
  在宏 M A L L O C的开始包含一个s p l i m p，在结束时有一个s p l x。宏M F R E E中包含同样的保护机制。由于 m b u f在内核的所有层中被分配和释放，因此内核必须保护那些用于存储器分配的数据结构。
  * 用于分配和释放m b u f簇的宏M C L A L L O C与M C L F R E E要用一个s p l i m p和一个s p l x
包括起来，因为它们修改的是一个可用簇链。因为存储器分配与释放及簇分配与释放的宏被保护起来防止被中断，我们通常在 M G E T和
m _ g e t这样的函数和宏的前后不再调用s p l函数。


*  m_devget和m_pullup函数
  * IP、ICMP、IGMP、UDP和TCP的代码时会遇到函数m_pullup它用来保证指定数目的字节 (相应协议首部的大小 )在链表的第一个 m b u f中紧挨着存放；即这些指定数目的字节被复制到一个新的 m b u f并紧接着存放。m_pullup的用法，必须查看它的实现及相关的函数m_devget和宏mtod与dtom



