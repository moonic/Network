# mbuf 

* 输入处理
输入处理与刚讲过的输出处理不同，因为输入是异步的。就是说，它是通过一个接收完
成中断驱动以太网设备驱动程序来接收一个输入分组，而不是通过进程的系统调用。内核处
理这个设备中断，并调度设备驱动程序进入运行状态。

* 以太网输入
以太网设备驱动程序处理这个中断，假定它
表示一个正常的接收已完成，数据从设备读到
一个m b u f链表中。在我们的例子中，接收了 5 4
字节的数据并复制到一个 m b u f中：2 0字节I P首
部、8字节U D P首部及2 6字节数据(服务器的时间
与日期)。图1 - 1 0所示的是这个m b u f的格式。
这个m b u f是一个分组首部(m _ f l a g s被设置
成M _ P K T H D R)，它是一个数据记录的第一个m b u f。
分组首部的成员 l e n包含数据的总长度，成员
r c v i f包含一个指针，它指向接收数据的接口的
接口结构(第3章)。我们可以看到成员r c v i f用
于接收分组而不是输出分组(图1 - 7和图1 - 8 )。
m b u f的前1 6字节数据空间被分配给一个接
口层首部，但没有使用。数据就存储在这个
m b u f中，5 4字节的数据存储在剩余的8 4字节的空间中。
设备驱动程序把m b u f传给一个通用以太网输入例程，它通过以太网帧中的类型字段来确
定哪个协议层来接收此分组。在这个例子中，类型字段标识一个 I P数据报，从而m b u f被加入
到I P输入队列中。另外，会产生一个软中断来执行 I P输入例程。这样，这个设备中断处理就
完成了。


* IP输入
I P输入是异步的，并且通过一个软中断来执行。当接口层在系统的一个接口上收到一个
I P数据报时，它就设置这个软中断。当 I P输入例程执行它时，循环处理在它的输入队列中的
每一个I P数据报，并在整个队列被处理完后返回。
I P输入例程处理每个接收到的 I P数据报。它验证I P首部检验和，处理I P选项，验证数据报
被传递到正确的主机(通过比较数据报的目标I P地址与主机I P地址)，并当系统被配置为一个路
由器，且数据报被表注为其他的 I P地址时，转发此数据报。如果 I P数据报到达它的最终目标，
调用I P首部中标识的协议的输入例程： I C M P，I G M P，T C P或U D P。在我们的例子中，调用
U D P输入例程去处理U D P数据报。

* UDP输入
U D P输入例程验证U D P首部中的各字段(长度与可选的检验和)，然后确定是否一个进程应
该接收此数据报。在第 2 3章我们要详细讨论这个检查是如何进行的。一个进程可以接收到一
指定U D P端口的所有数据报，或让内核根据源与目标 I P地址及源与目标端口号来限制数据报
的接收。
在我们的例子中， U D P输入例程从一个全局变量 u d b(图1 - 5 )开始，查看所有U D P协议控
制块链表，寻找一个本地端口号 ( i n p _ l p o r t)与接收的U D P数据报的目标端口号匹配的协议
控制块。这个P C B是由我们调用s o c k e t创建的，它的成员i n p _ s o c k e t指向相应插口结构，
并允许接收的数据在此插口排队。
在程序示例中，我们从未为应用程序指定本地端口号。在习题 2 3 . 3中，我们会看
到在写第一个U D P程序时创建一个插口而不绑定一个本地端口号会导致内核自动地
给此插口分配一个本地端口号 (称为短期端口 )。这就是为什么插口的 P C B成员
i n p _ l p o r t不是一个空值的原因。
因为这个U D P数据报要传递给我们的进程，发送方的 I P地址和U D P端口号被放置到一个
m b u f中，这个m b u f和数据(在我们的例子中是 2 6字节)被追加到此插口的接收队列中。图 1 - 11
所示的是被追加到这个插口的接收队列中的这两个 m b u f。


* 进程输入
我们的进程调用 r e c v f r o m时被阻塞，在内核中处于睡眠状态，现在进程被唤醒。 U D P
层追加到插口接收队列中的 2 6字节的数据(接收的数据报)被内核从m b u f复制到我们程序的缓
存中。
注意，我们的程序把 r e c v f o r m的第5，第6个参数设置为空指针，告诉系统在接收过程
中不关心发送方的 I P地址和U D P端口号。这使得系统调用 r e c v f r o m时，略过链表中的第一
个m b u f (图1 - 11 )，仅返回第二个m b u f中的2 6字节的数据。然后内核的r e c v f r o m代码释放图1 -
11中的两个m b u f，并把它们放回到自由m b u f池中。

