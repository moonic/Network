# mbuf
> 存储器缓存，称作一个 m b u f，在整个联网
代码中用于存储各种信息。通过我们的简单例子 (图1 - 2 )分析一些m b u f的典型用法。在第2章中
我们会更详细地说明m b u f。

* 包含插口地址结构的m b u f
在s e n d t o调用中，第5个参数指向一个I n t e r n e t插口地址结构(叫s e r v )，第6个参数指示它
的长度(后面我们将要看到是1 6个字节)。插口层为这个系统调用做的第一件事就是验证这些参
数是有效的(即这个指针指向进程地址空间的一段存储器 )，并且将插口地址结构复制到一个
m b u f中。图1 - 6所示的是这个所得到的m b u f。
m b u f的前2 0个字节是首部，它包含关于这个 m b u f的一些信息。这2 0个字节的首部包括四
个4字节字段和两个2字节字段。m b u f的总长为1 2 8个字节。


* 包含数据的m b u f
下面继续讨论我们的例子，插口层将 s e n d t o调用中指定的数据缓存中的数据复制到一个或
多个m b u f中。s e n d t o的第二个参数指示了数据缓存 ( b u ff )的开始位置，第三个参数是它的大
小( 1 5 0字节)。图1 - 7显示了1 5 0字节的数据是如何存储在两个 mbuf 中的。
m b u f链表。在每个m b u f中的成员m _ n e x t把链表中所有的m b u f都链接在一
起。
我们看到的另一个变化是链表中第一个m b u f的m b u f首部的另外两个成员：m _ p k t h d r . l e n
和m _ p k t h d r . r c v i f。这两个成员组成了分组首部并且只用在链表的第一个 m b u f中。成员
m _ f l a g s的值是M _ P K T H D R，指示这个m b u f包含一个分组首部。分组首部结构的成员 l e n包含
了整个m b u f链表的总长度(在本例中是1 5 0 )，下一个成员r c v i f在后面我们会看到，它包含了
一个指向接收分组的接收接口结构的指针。
因为m b u f总是1 2 8个字节，在链表的第一个 m b u f中提供了1 0 0字节的数据存储能力，而后
面所有的m b u f有1 0 8字节的存储空间。在本例中的两个 m b u f需要存储1 5 0字节的数据。我们稍
后会看到当数据超过2 0 8字节时，就需要3个或更多的m b u f。有一种不同的技术叫“簇”，一种
大缓存，典型的有1 0 2 4或2 0 4 8字节。
在链表的第一个m b u f中维护一个带有总长度的分组首部的原因是，当需要总长度时可以
避免查看所有m b u f中的m _ l e n来求和。

* 添加I P和U D P首部
插口层将目标插口地址结构复制到一个 m b u f中，并把数据复制到 m b u f链中后，与此插
口描述符 (一个U D P描述符)对应的协议层被调用。明确地说， U D P输出例程被调用，指向
m b u f的指针被作为一个参数传递。这个例程要在这 1 5 0字节数据的前面添加一个I P首部和一个
U D P首部，然后将这些m b u f传递给I P输出例程。
I P首部和U D P首部被放置在新 m b u f的最后，这个新 m b u f就成了整个链表的首部。如果
需要，它允许任何其他低层协议 (例如接口层)在I P首部前添加自己的首部，而不需要再复制
I P和U D P首部。在第一个 m b u f中的m _ d a t a指针指向这两个首部的起始位置， m _ l e n的值是
2 8。在分组首部和 I P首部之间有 7 2字节的未用空间留给以后的首部，通过适当地修改
m _ d a t a指针和m _ l e n添加在I P首部的前面。稍后我们会看见以太网首部就是用这种方法建
立的。
注意，分组首部已从带有 1 0 0字节数据的m b u f中移到新m b u f中去了。分组首部必须放在
m b u f链表的第一个m b u f中。在移动分组首部的同时，在第一个 m b u f设置M _ P K T H D R标志并且
在第二个m b u f中清除此标志。在第二个 m b u f中分组首部占用的空间现在未用。最后，在此分
组首部中的长度成员由于增加了28 字节而变成了1 7 8。
然后U D P输出例程填写U D P首部和I P首部中它们所能填写的部分。例如， I P首部中的目
标地址可以被设置，但I P检验和要留给I P输出例程来计算和存放。
U D P检验和计算后存储在U D P首部中。注意，这要求遍历存储在 m b u f链表中的所有1 5 0字
节的数据。这样，内核要对这 1 5 0字节的用户数据做两次遍历：一次是把用户缓存中的数据复
制到内核中的m b u f中，而现在是计算U D P检验和。对整个数据的额外遍历会降低协议的性能


* IP输出
I P输出例程要填写I P首部中剩余的字段，包括I P检验和；确定数据报应发到哪个输出接口
(这是I P路由功能)；必要时，对I P报文分片；以及调用接口输出函数。
假设输出接口是一个以太网接口，再次把此 m b u f链表的指针作为一个参数，调用一个通
用的以太网输出

* 以太网输出
以太网输出函数的第一个功能就是把 3 2位I P地址转换成相应的 4 8位以太网地址。在使用
A R P (地址解析协议)时会使用这个功能，并且会在以太网上发送一个 A R P请求并等待一个A R P
应答。此时，要输出的m b u f链表已得到，并等待应答。
然后以太网输出例程把一个 1 4字节的以太网首部添加到链表的第一个 m b u f中，紧接在I P
首部的前面(图1 - 8 )。以太网首部包括6字节以太网目标地址、6字节以太网源地址和2字节以太
网帧类型。
之后此m b u f链表被加到此接口的输出队列队尾。如果接口不忙，接口的“开始输出”例
程立即被调用。若接口忙，在它处理完输出队列中的其他缓存后，它的输出例程会处理队列
中的这个新m b u f。
当接口处理它输出队列中的一个 m b u f时，它把数据复制到它的传输缓存中，并且开始输
出。在我们的例子中， 1 9 2字节被复制到传输缓存中： 1 4字节以太网首部、 2 0字节I P首部、8
字节U D P首部及1 5 0字节用户数据。这是内核第三次遍历这些数据。一旦数据从 m b u f链表被复
制到设备传输缓存，m b u f链表就被以太网设备驱动程序释放。这三个 m b u f被放回到内核的自
由缓存池中。


* UDP输出
进程调用 s e n d t o传输一个U D P数据报时的大致处理过程。在图
中我们说明的处理过程与三层内核代码 (图1 - 3 )的关系也显示出来了
函数调用控制从插口层到 U D P输出例程，到I P输出例程，然后到以太网输出例程。每个
函数调用传递一个指向要输出的 m b u f的指针。在最低层，设备驱动程序层， m b u f链表被放置
到设备输出队列并启动设备。函数调用按调用的相反顺序返回，最后系统调用返回给进程。
注意，直到U D P数据报到达设备驱动程序前， U D P数据没有排队。高层仅仅添加它们的协议
首部并把m b u f传递给下一层。
这时，在我们的程序示例中调用r e c v f r o m去读取服务器的应答。因为该插口的输入队列是
空的(假设应答还没有到达)，进程就进入睡眠状态。

