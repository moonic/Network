# UDP：用户数据报协议
> U D P是不可靠的面向数据报的运输层协议：进程的每个输出操作都正好产生一个 U D P数据报，并组装成一份待发送的 I P数据报。这与面向流字符的协议不同，如 T C P，应用程序产生的全体数据与真正发送的单个 I P数据报可能没有什么联系 U D P数据报封装成一份I P数据报的格式.它把应用程序传给 I P层的数据发送出去，但是并不保证它们能到达目的地

* UDP首部
端口号表示发送进程和接收进程。在图 1 - 8中，我们画出了T C P和U D P用目的端口号来分
用来自I P层的数据的过程。由于I P层已经把I P数据报分配给T C P或U D P（根据I P首部中协议字
段值），因此T C P端口号由T C P来查看，而U D P端口号由U D P来查看。T C P端口号与U D P端口
号是相互独立的。

U D P长度字段指的是U D P首部和U D P数据的字节长度。该字段的最小值为 8字节（发送一
份0字节的U D P数据报是O K）。这个U D P长度是有冗余的。 I P数据报长度指的是数据报全长
（图3 - 1），因此U D P数据报长度是全长减去 I P首部的长度（该值在首部长度字段中指定，如图
3 - 1所示）。

* UDP检验和
U D P检验和覆盖U D P首部和U D P数据。回想I P首部的检验和，它只覆盖I P的首部 — 并不
覆盖I P数据报中的任何数据。
U D P和T C P在首部中都有覆盖它们首部和数据的检验和。 U D P的检验和是可选的，而T C P
的检验和是必需的。
尽管U D P检验和的基本计算方法与我们在 3 . 2节中描述的 I P首部检验和计算方法相类似
（16 bit字的二进制反码和），但是它们之间存在不同的地方。首先， U D P数据报的长度可以为
奇数字节，但是检验和算法是把若干个 16 bit字相加。解决方法是必要时在最后增加填充字节
0，这只是为了检验和的计算（也就是说，可能增加的填充字节不被传送）。
其次，U D P数据报和T C P段都包含一个1 2字节长的伪首部，它是为了计算检验和而设置
的。伪首部包含 I P首部一些字段。其目的是让 U D P两次检查数据是否已经正确到达目的地
（例如，I P没有接受地址不是本主机的数据报，以及 I P没有把应传给另一高层的数据报传给
U D P）。U D P数据报中的伪首部格式如图11 - 3所示。
如果检验和的计算结果为 0，则存入的值为全 1（6 5 5 3 5），这在二进制反码计算中是等效
的。如果传送的检验和为0，说明发送端没有计算检验和。
果发送端没有计算检验和而接收端检测到检验和有差错，那么 U D P数据报就要被悄悄
地丢弃。不产生任何差错报文（当 I P层检测到I P首部检验和有差错时也这样做）。
U D P检验和是一个端到端的检验和。它由发送端计算，然后由接收端验证。其目的是为
了发现U D P首部和数据在发送端到接收端之间发生的任何改动。

Host Requirements RFC声明，U D P检验和选项在默认条件下是打开的。它还声明，
如果发送端已经计算了检验和，那么接收端必须检验接收到的检验和（如接收到检验
和不为0）。但是，许多系统没有遵守这一点，只是在出口检验和选项被打开时才验证
接收到的检验和。

* tcpdump输出
  * 应用程序通常不可能得到接收到的U D P首部中的检验和。为了得到这一点，作者在 t c p d u m p程序中增加了一个选项，以打印出接收到的U D P检验和。如果打印出的值为0，说明发送端没有计算检验和。测试网络上三个不同系统的输出如图 11 - 4所示 运行我们自编的s o c k程序（附录C），发送一份包含9个字节数据的U D P数据报给标准回显服务器。三个系统中有两个打开了 U D P检验和选项。
  * 送出的数据报与收到的数据报具有相同的检验和值从图11-3可以看出，两个IP地址进行了交换，正如两个端口号一样。伪首部和U D P首部中的其他字段都是相同的，就像数据回显一样。这再次表明 U D P检验和（事实上，TCP/IP协议簇中所有的检验和）是简单的16 bit和。.

* IP分片
  * 物理网络层一般要限制每次发送数据帧的最大长度。何时I P层接收到一份要发送的 I P数据报时，要判断向本地哪个接口发送数据（选路），并查
询该接口获得其M T U。I P把M T U与数据报长度进行比较，如果需要则进行分片。分片可以发生在原始发送端主机上，也可以发生在中间路由器上。
  * 把一份I P数据报分片以后，只有到达目的地才进行重新组装（这里的重新组装与其他网络协议不同，它们要求在下一站就进行进行重新组装，而不是在最终的目的地）。重新组装由目的端的I P层来完成，其目的是使分片和重新组装过程对运输层（ T C P和U D P）是透明的，除了某些可能的越级操作外。已经分片过的数据报有可能会再次进行分片（可能不止一次）。
  * I P首部中包含的数据为分片和重新组装提供了足够的信息
    * 回忆I P首部（图3 - 1），下面这些字段用于分片过程。对于发送端发送的每份I P数据报来说，其标识字段都包含一个唯一值。该值在数据报分片时被复制到每个片中（我们现在已经看到这个字段的用途）。标志字段用其中一个比特来表示“更多的片”。除了最后一片外，其他每个组成数据报的片都要把该比特置 1。
    * 片偏移字段指的是该片偏移原始数据报开始处的位置 当数据报被分片后，每个片的总长度值要改为该片的长度值。最后，标志字段中有一个比特称作“不分片”位。如果将这一比特置 1，I P将不对数据报进行分片。相反把数据报丢弃并发送一个 I C M P差错报文（“需要进行分片但设置了不分片比特”，见图6 - 3）给起始端
    * 当I P数据报被分片后，每一片都成为一个分组，具有自己的 I P首部，并在选择路由时与其他分组独立。这样，当数据报的这些片到达目的端时有可能会失序，但是在 I P首部中有足够的信息让接收端能正确组装这些数据报片。尽管I P分片过程看起来是透明的即使只丢失一片数据也要重传整个数据报
      * 因为 I P层本身没有超时重传的机制——由更高层来负责超时和重传（T C P有超时和重传机制，但U D P没有。一些U D P应用程序本身也执行超时和
重传）。当来自T C P报文段的某一片丢失后，T C P在超时后会重发整个T C P报文段，该报文段对应于一份I P数据报。没有办法只重传数据报中的一个数据报片。事实上，如果对数据报分片的是中间路由器，而不是起始端系统，那么起始端系统就无法知道数据报是如何被分片的。就这个原因，经常要避免分片。
  * 文献[Kent and Mogul 1987]对避免分片进行了论述。
  * 使用U D P很容易导致I P分片（在后面我们将看到，T C P试图避免分片，但对于应用程序来
说几乎不可能强迫 T C P发送一个需要进行分片的长报文段）。我们可以用s o c k程序来增加数
据报的长度，直到分片发生。在一个以太网上，数据帧的最大长度是 1 5 0 0字节（见图2 - 1），
其中1 4 7 2字节留给数据，假定 I P首部为2 0字节，U D P首部为8字节。我们分别以数据长度为
1471, 1472, 1473和1 4 7 4字节运行s o c k程序。最后两次应该发生分片
  * 当I P数据报被分片后，t c p d u m p打印出其他的信息。首先，frag 26304（第3行和第4
行）和frag 26313 （第5行和第6行）指的是I P首部中标识字段的值。
  * 分片时，除最后一片外，其他每一片中的数据部分（除 I P首部外的其余部分）必须是 8字节的整数倍

* ICMP不可达差错（需要分片）
  * 发生I C M P不可达差错的另一种情况是，当路由器收到一份需要分片的数据报，而在 I P首部又设置了不分片（D F）的标志比特。如果某个程序需要判断到达目的端的路途中最小 M T U是多少 — 称作路径M T U发现机制（2 . 9节），那么这个差错就可以被该程序使用。
  * 这种情况下的I C M P不可达差错报文格式如图 11 - 9所示。这里的格式与图 6 - 1 0不同，因为
    在第2个32 bit字中，16~31 bit可以提供下一站的M T U，而不再是0如果路由器没有提供这种新的I C M P差错报文格式下一站的M T U就设为0。
  * 新版的路由器需求RFC [Almquist 1993]声明，在发生这种I C M P不可达差错时，路由器必须生成这种新格式的报文。
