# UDP：用户数据报协议
> U D P是不可靠的面向数据报的运输层协议：进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报 与面向流字符的协议不同 如 T C P，应用程序产生的全体数据与真正发送的单个IP数据报可能没有什么联系UDP数据报封装成一份I P数据报的格式.它把应用程序传给IP层的数据发送出去，但是并不保证它们能到达目的地

* UDP首部
  * 端口号表示发送进程和接收进程 由于I P层已经把I P数据报分配给T C P或U D P（根据I P首部中协议字
段值），因此T C P端口号由T C P来查看，而U D P端口号由U D P来查看。T C P端口号与U D P端口
号是相互独立的。

U D P长度字段指的是U D P首部和U D P数据的字节长度。该字段的最小值为 8字节（发送一
份0字节的U D P数据报是O K）。这个U D P长度是有冗余的。 I P数据报长度指的是数据报全长
（图3 - 1），因此U D P数据报长度是全长减去 I P首部的长度（该值在首部长度字段中指定，如图
3 - 1所示）。

* UDP检验和
U D P检验和覆盖U D P首部和U D P数据。回想I P首部的检验和，它只覆盖I P的首部 — 并不
覆盖I P数据报中的任何数据。
U D P和T C P在首部中都有覆盖它们首部和数据的检验和。 U D P的检验和是可选的，而T C P
的检验和是必需的。
尽管U D P检验和的基本计算方法与我们在 3 . 2节中描述的 I P首部检验和计算方法相类似
（16 bit字的二进制反码和），但是它们之间存在不同的地方。首先， U D P数据报的长度可以为
奇数字节，但是检验和算法是把若干个 16 bit字相加。解决方法是必要时在最后增加填充字节
0，这只是为了检验和的计算（也就是说，可能增加的填充字节不被传送）。
其次，U D P数据报和T C P段都包含一个1 2字节长的伪首部，它是为了计算检验和而设置
的。伪首部包含 I P首部一些字段。其目的是让 U D P两次检查数据是否已经正确到达目的地
（例如，I P没有接受地址不是本主机的数据报，以及 I P没有把应传给另一高层的数据报传给
UDP数据报中的伪首部格式如图11 - 3所示。
如果检验和的计算结果为 0，则存入的值为全 1（6 5 5 3 5），这在二进制反码计算中是等效
的。如果传送的检验和为0，说明发送端没有计算检验和。
果发送端没有计算检验和而接收端检测到检验和有差错，那么 U D P数据报就要被悄悄
地丢弃。不产生任何差错报文（当 I P层检测到I P首部检验和有差错时也这样做）。
U D P检验和是一个端到端的检验和。它由发送端计算，然后由接收端验证。其目的是为
了发现U D P首部和数据在发送端到接收端之间发生的任何改动。

Host Requirements RFC声明，U D P检验和选项在默认条件下是打开的。它还声明，
如果发送端已经计算了检验和，那么接收端必须检验接收到的检验和（如接收到检验
和不为0）。但是，许多系统没有遵守这一点，只是在出口检验和选项被打开时才验证
接收到的检验和。

* tcpdump输出
  * 应用程序通常不可能得到接收到的U D P首部中的检验和。为了得到这一点，作者在 t c p d u m p程序中增加了一个选项，以打印出接收到的U D P检验和。如果打印出的值为0，说明发送端没有计算检验和。测试网络上三个不同系统的输出如图 11 - 4所示 运行我们自编的s o c k程序（附录C），发送一份包含9个字节数据的U D P数据报给标准回显服务器。三个系统中有两个打开了 U D P检验和选项。
  * 送出的数据报与收到的数据报具有相同的检验和值从图11-3可以看出，两个IP地址进行了交换，正如两个端口号一样。伪首部和U D P首部中的其他字段都是相同的，就像数据回显一样。这再次表明 U D P检验和（事实上，TCP/IP协议簇中所有的检验和）是简单的16 bit和。.

* IP分片
  * 物理网络层一般要限制每次发送数据帧的最大长度。何时I P层接收到一份要发送的 I P数据报时，要判断向本地哪个接口发送数据（选路），并查
询该接口获得其M T U。I P把M T U与数据报长度进行比较，如果需要则进行分片。分片可以发生在原始发送端主机上，也可以发生在中间路由器上。
  * 把一份I P数据报分片以后，只有到达目的地才进行重新组装（这里的重新组装与其他网络协议不同，它们要求在下一站就进行进行重新组装，而不是在最终的目的地）。重新组装由目的端的I P层来完成，其目的是使分片和重新组装过程对运输层（ T C P和U D P）是透明的，除了某些可能的越级操作外。已经分片过的数据报有可能会再次进行分片（可能不止一次）。
  * I P首部中包含的数据为分片和重新组装提供了足够的信息
    * 回忆I P首部（图3 - 1），下面这些字段用于分片过程。对于发送端发送的每份I P数据报来说，其标识字段都包含一个唯一值。该值在数据报分片时被复制到每个片中（我们现在已经看到这个字段的用途）。标志字段用其中一个比特来表示“更多的片”。除了最后一片外，其他每个组成数据报的片都要把该比特置 1。
    * 片偏移字段指的是该片偏移原始数据报开始处的位置 当数据报被分片后，每个片的总长度值要改为该片的长度值。最后，标志字段中有一个比特称作“不分片”位。如果将这一比特置 1，I P将不对数据报进行分片。相反把数据报丢弃并发送一个 I C M P差错报文（“需要进行分片但设置了不分片比特”，见图6 - 3）给起始端
    * 当I P数据报被分片后，每一片都成为一个分组，具有自己的 I P首部，并在选择路由时与其他分组独立。这样，当数据报的这些片到达目的端时有可能会失序，但是在 I P首部中有足够的信息让接收端能正确组装这些数据报片。尽管I P分片过程看起来是透明的即使只丢失一片数据也要重传整个数据报
      * 因为 I P层本身没有超时重传的机制——由更高层来负责超时和重传（T C P有超时和重传机制，但U D P没有。一些U D P应用程序本身也执行超时和
重传）当来自T C P报文段的某一片丢失后，T C P在超时后会重发整个T C P报文段，该报文段对应于一份I P数据报。没有办法只重传数据报中的一个数据报片。事实上，如果对数据报分片的是中间路由器，而不是起始端系统，那么起始端系统就无法知道数据报是如何被分片的。就这个原因，经常要避免分片。
  * 文献[Kent and Mogul 1987]对避免分片进行了论述。
  * 使用U D P很容易导致I P分片（在后面我们将看到，T C P试图避免分片，但对于应用程序来
说几乎不可能强迫 T C P发送一个需要进行分片的长报文段）。我们可以用s o c k程序来增加数
据报的长度，直到分片发生。在一个以太网上，数据帧的最大长度是 1 5 0 0字节（见图2 - 1），
其中1 4 7 2字节留给数据，假定 I P首部为2 0字节，U D P首部为8字节。我们分别以数据长度为
1471, 1472, 1473和1 4 7 4字节运行s o c k程序。最后两次应该发生分片
  * 当I P数据报被分片后，t c p d u m p打印出其他的信息。首先，frag 26304（第3行和第4
行）和frag 26313 （第5行和第6行）指的是I P首部中标识字段的值。
  * 分片时，除最后一片外，其他每一片中的数据部分（除 I P首部外的其余部分）必须是 8字节的整数倍

* ICMP不可达差错（需要分片）
  * 发生I C M P不可达差错的另一种情况是，当路由器收到一份需要分片的数据报，而在 I P首部又设置了不分片（D F）的标志比特。如果某个程序需要判断到达目的端的路途中最小 M T U是多少 — 称作路径M T U发现机制 这个差错就可以被该程序使用。
  * 这种情况下的I C M P不可达差错报文格式如图 11 - 9所示。这里的格式与图 6 - 1 0不同，因为
    在第2个32 bit字中，16~31 bit可以提供下一站的M T U，而不再是0如果路由器没有提供这种新的I C M P差错报文格式下一站的M T U就设为0。
  * 新版的路由器需求RFC [Almquist 1993]声明，在发生这种I C M P不可达差错时，路由器必须生成这种新格式的报文。
  *  I C M P差错试图判断从路由器 netb到主机sun之间的拨号SLIP链路的M T U从s u n到n e t b的链路的MTU：当SLIP被安装到主机s u n时是SLIP配置过程中的一部分已经通过netstat命令观察过。从另一个方向来判断它的M T U（如何用S N M P来判断)在点到点的链路中 不要求两个方向的M T U为相同值。
    * 主机solaris上运行ping程序到主机b s d i增加数据分组长度，直到看见进入的分组被分片为止


* Traceroute确定路径MTU
  * 修改traceroute程序用它来确定路径MT U发送分组，并设置“不分片”标志比特。发送的第一个分组的长度正好与出口MTU相等，每次收到ICMP“不能分片”差错时减小分组的长度。如果路由器发送的 I C M P差错报文是新格式，包含出口的M T U，那么就用该M T U值来发送，否则就用下一个最小的 M T U值来发送正如RFC 1191 [Mogul andDeering 1990]M T U值的个数是有限因此在我们的程序中有一些由近似值构成的表 取下一个最小M T U值来发送
  * 不是所有的广域网都可以处理大于 5 1 2字节的分组。利用路径M T U发现机制，应用程序就可以充分利用更大的 M T U来发送报文
 
* UDP的路径MTU发现
  * U D P的应用程序与路径M T U发现机制之间的交互作用 应用程序写了一个对于一些中间链路来说太长的数据报
  * 支持路径M T U发现机制的唯一系统就是Solaris 2.x，因此，将采用它作为源站发送一份6 5 0字节数据报经s l i p。由于s l i p主机位于M T U为2 9 6的SLIP链路后，因此，任何长于2 6 8字节且“不分片”比特置为1的U D P数据都会使bsdi路由器产生I C M P“不能分片”差错报文。图11 - 1 3给出了拓扑结构和M T U。
  * I P已经知道了发往该目的地址的数据报不能将 D F比特置1，因此，I P进而将数据报在源站主机上进行分片。这与前面的例子中， I P发送经过U D P的数据报，允许具有较小M T U的路由器（在本例中是 b s d i）对它进行分片的情况不同

* UDP和ARP之间的交互作用
  * 使用U D P，可以看到U D P与A R P典型实现之间的有趣的（而常常未被人提及）交互作用。
我们用s o c k程序来产生一个包含8 1 9 2字节数据的U D P数据报。预测这将会在以太网上产
生6个数据报片（见习题 11 . 3）。同时也确保在运行该程序前， A R P缓存是清空的，这样，在
发送第一个数据报片前必须交换A R P请求和应答。
最后一个 A R P应答返回后，继续运行 t c p d u m p程序5分钟，以看看
s v r 4是否会返回I C M P“组装超时”差错。并没有发送 I C M P差错（我们在图 8 - 2中给出了该
消息的格式。c o d e字段为1表示在重新组装数据报时发生了超时）。

* 最大UDP数据报长度
  * I P数据报的最大长度是6 5 5 3 5字节，这是由I P首部（图3 - 1）1 6比特总长度字段所限制的。去除 2 0字节的I P首部和8个字节的U D P首部，U D P数据报中用户数据的最长长度为6 5 5 0 7字节。但是，大多数实现所提供的长度比这个最大值小
    * 第一，应用程序可能会受到其程序接口的限制。 socket API提供了一个可供应用程序调用的函数，以设置接收和发送缓存的长度。对于 UDP socket，这个
长度与应用程序可以读写的最大 U D P数据报的长度直接相关。现在的大部分系统都默认提供了可读写大于8 1 9 2字节的U D P数据报（使用这个默认值是因为 8 1 9 2是N F S读写用户数据数的默认值）。
    * 第二个限制来自于T C P / I P的内核实现。可能存在一些实现特性（或差错），使I P数据报长度小于6 5 5 3 5字节。
  * 在SunOS 4.1.3下使用环回接口的最大I P数据报长度是3 2 7 6 7字节。比它大的值都会发生差错。但是从B S D / 3 8 6到SunOS 4.1.3的情况下，S u n所能接收到最大I P数据报长度为3 2 7 8 6字节（即32758字节用户数据）。在Solaris 2.2下使用环回接口，最大可收发 I P数据报长度为6 5 5 3 5字节。限制与源端和目的端的实现有关
  
* ICMP源站抑制差错
  * U D P产生I C M P“源站抑制(source quench)”差错。当一个系统（路由器或主机）接收数据报的速度比其处理速度快时 可能产生差错。注意限定词“可能”。即使一个系统已经没有缓存并丢弃数据报，也不要求它一定要发送源站抑制报文。
  * 以 9600 b/s速率传送1 0 2 4字节数据报只需要1秒时间（由于从s u n到n e t b的S L I P链路的MTU为5 5 2字节，因此在我们的例子中， 20 + 8 +1 0 2 4字节数据报将进行分片，因此，其时间会稍长一些）
    * RFC 1009 [Braden and Postel 1987] 要求路由器在没有缓存时产生源站抑制差错报文，但是新的Router Requirements RFC [Almquist 1993] 对此作了修改，提出路由器不应该产生源站抑制差错报文。由于源站抑制要消耗网络带宽，且对于拥塞来说是一种无效而不公平的调整，因此现在人们对于源站抑制差错的态度是不支持的。
 
 
## 小结
  * U D P是一个简单协议。它的正式规范是 RFC 768 [Postel 1980]，只包含三页内容。它向用户进程提供的服务位于 I P层之上，包括端口号和可选的检验和。我们用 U D P来检查检验和，并观察分片是如何进行的。
  * I C M P不可达差错，它是新的路径 M T U发现功能中的一部分（ 2 . 9节）。用Tr a c e r o u t e和U D P来观察路径M T U发现过程。还查看了 U D P和A R P之间的接口，大多数的A R P实现在等待A R P应答时只保留最近传送给目的端的数据报。当系统接收I P数据报的速率超过这些数据报被处理的速率时，系统可能发送 I C M P源站抑制差错报文。使用U D P时很容易产生这样的I C M P差错。
