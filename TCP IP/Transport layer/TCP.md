# TCP 传输控制协议
> 提供一种面向连接的、可靠的字节流服务。
面向连接意味着两个使用 T C P的应用（通常是一个客户和一个服务器）在彼此交换数据
之前必须先建立一个 T C P连接。这一过程与打电话很相似，先拨号振铃，等待对方摘机说
“喂”，然后才说明是谁


## TCP的服务
* TCP和UDP都使用相同的网络层（I P）在一个T C P连接中，仅有两方进行彼此通信 广播和多播不能用于T C P

* TCP通过下列方式来提供可靠性：
  * 数据分割: 应用数据分割成TCP认为最适合发送的数据块 和 U D P完全不同，应用程序产生的数据报长度将保持不变 TCP传递给I P的信息单位称为报文段或段（segment）TCP如何确定报文段的长度
  * TCP发出一个段后，它启动一个定时器: 等待目的端确认收到这个报文段。如果不能及时收到一个确认，将发这个报文段。T C P协议中自适应的超时及重传策略TC P收到发自T C P连接另一端的数据，它将发送一个确认不是立即发送，通常将推迟几分之一秒
  * TCP首部和数据的检验和: 端到端的检验和，目的是检测数据在传输过程中的任何变化如果收到段的检验和有差错TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发既,然T C P报文段作为I P数据报来传输，而I P数据报的到达可能会失序，因此 T C P报文段的到达也可能会失序TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层 I P数据报会发生重复，T C P的接收端必须丢弃重复的数据。
  * T C P还能提供流量控制: T C P连接的每一方都有固定大小的缓冲空间TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。将防止较快主机致使较慢主机的缓冲区溢出。

* 两个应用程序通过TCP连接交换8 bit字节构成的字节流T C P不在字节流中插入记录标识符
  * 我们将这称为字节流服务（byte stream service）。如果一方的应用程序先传1 0字节，又传
2 0字节，再传5 0字节，连接的另一方将无法了解发方每次发送了多少字节。收方可以分 4次接
收这8 0个字节
  * 每次接收 2 0字节。一端将字节流放到 T C P连接上，同样的字节流将出现在T C P连接的另一端。 

## TCP的首部
* 每个T C P段都包含源端和目的端的端口号，用于寻找发端和收端应用进程这两个值加
上I P首部中的源端I P地址和目的端I P地址唯一确定一个T C P连接。
  * 一个I P地址和一个端口号也称为一个插口（ s o c k e t）。这个术语出现在最早的 T C P
规范（RFC793）中，后来它也作为表示伯克利版的编程接口（参见 1 . 1 5节）。
  * 插口对（socket pair）(包含客户I P地址、客户端口号、服务器 I P地址和服务器端口号的四元组 )可唯一确定互
联网络中每个T C P连接的双方。

* 序号
  * 用来标识从TCP发端向T C P收端发送的数据字节流，它表示在这个报文段中的的第一
个数据字节。如果将字节流看作在两个应用程序间的单向流动，则 T C P用序号对每个字节进
行计数。
  * 序号是32 bit的无符号数，序号到达2 3 2 －1后又从0开始。当建立一个新的连接时
  S Y N标志变1。序号字段包含由这个主机选择的该连接的初始序号I S N（Initial Sequence Number）
  该主机要发送数据的第一个字节序号为这个 I S N加1，因为S Y N标志消耗了一个序号
  * 既然每个传输的字节都被计数，确认序号包含发送确认的一端所期望收到的下一个序号
  因此，确认序号应当是上次已成功收到数据字节序号加 1。只有A C K标志（下面介绍）为 1时确认序号字段才有效。
  * 发送A C K无需任何代价，因为32 bit的确认序号字段和A C K标志一样，总是T C P首部的一
部分。因此，我们看到一旦一个连接建立起来，这个字段总是被设置ACK标志也总是被设置为1

* TCP为应用层提供全双工服务数据能在两个方向上独立地进行传输所以连接的每一端必须保持每个方向上的传输数据序号。
  * TCP可以表述为一个没有选择确认或否认的滑动窗口协议（滑动窗口协议用于数据传输
将在2 0 . 3节介绍）。我们说T C P缺少选择确认是因为 T C P首部中的确认序号表示发方已成功收
到字节，但还不包含确认序号所指的字节。当前还无法对数据流中选定的部分进行确认
  * 例如，如果1～1 0 2 4字节已经成功收到，下一报文段中包含序号从 2 0 4 9～3 0 7 2的字节，收端并不
能确认这个新的报文段。它所能做的就是发回一个确认序号为 1 0 2 5的A C K。它也无法对一个
报文段进行否认。例如，如果收到包含 1 0 2 5～2 0 4 8字节的报文段，但它的检验和错， T C P接
收端所能做的就是发回一个确认序号为 1 0 2 5的A C K。在2 1 . 7节我们将看到重复的确认如何帮助确定分组已经丢失。
  * 首部长度给出首部中32 bit字的数目。需要这个值是因为任选字段的长度是可变的。这个
字段占4 bit，因此T C P最多有6 0字节的首部。然而，没有任选字段，正常的长度是 2 0字节。
在T C P首部中有6个标志比特。它们中的多个可同时被设置为 1 

* 我们在这儿简单介绍它们的用法
  * U R G 紧急指针（u rgent pointer）有效（见2 0 . 8节）。
  * A C K 确认序号有效。
  * P S H 接收方应该尽快将这个报文段交给应用层。
  * R S T 重建连接。
  * S Y N 同步序号用来发起一个连接。这个标志和下一个标志将在第 1 8章介绍。
  * F I N 发端完成发送任务。

## TCP连接的建立与终止
>  T C P连接是如何建立的以及通信结束后是如何终止的 这种两端间连接的建立与无连接协议如UDP不同

* 连接的建立与终止
为了了解一个TCP连接在建立及终止时发生了什么，我们在系统svr4上键入下列命令：
telnet命令在与丢弃(discard)服务对应的端口上与主机 bsdi建立一条TCP连接
这服务类型正是我们需要观察的一条连接建立与终止的服务类型而不需要服务器发起任何数据交换

* RFC 1025 
  * [Postel 1987], “TCP and IP Bake Off”，将一种报文段称为Kamikaze分组
  在这样的报文段中有最大数量的标志比特同时被置为1（SYN,URG,PSH,FIN和1字节的
数据） 报文段也叫作nastygram, 圣诞树分组，灯测试报文段(lamp test segment)。
  * 在第1行中，字段1415531521:1415531521(0)表示分组的序号是1415531521而报文段中
数据字节数为0。t c p d u m p显示这个字段的格式是开始的序号、一个冒号、隐含的结尾序号
及圆括号内的数据字节数。显示序号和隐含结尾序号的优点是便于了解数据字节数大于 0时的
隐含结尾序号。这个字段只有在满足条件报文段中至少包含一个数据字节；
  * 或者（ 2）S Y N、F I N或R S T被设置为1时才显示。第1、2、4和6行是因为标志比特被置为1而
显示这个字段的，在这个例子中通信双方没有交换任何数据。
  * 在第2行中，字段ack 1415531522 表示确认序号。它只有在首部中的ACK标志比特被设置1时才显示。
每行显示的字段win 4096表示发端通告的窗口大小 没有交换任何数据，窗口大小就维持默认情况下的4096

* 时间系列
  1. 请求端（通常称为客户）发送一个 SYN段指明客户打算连接的服务器的端口，以及初
始序号（I S N，在这个例子中为1415531521）这个S Y N段为报文段1
  2. 服务器发回包含服务器的初始序号的 S Y N报文段（报文段2）作为应答同时，将确认
序号设置为客户的ISN加1以对客户的SYN报文段进行确认 一个SYN将占用一个序号
  3. 客户必须将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认 报文段3

* 连接终止协议
  * 建立一个连接需要三次握手，而终止一个连接要经过 4次握手
  * T C P的半关闭（half-close造成的 TCP连接是全双工（即数据在两个方向上能同时传递）每个方
向必须单独地进行关闭。就是当一方完成它的数据发送任务后就能发送一个 F I N来终止这个方向连接
  * 当一端收到一个 F I N，它必须通知应用层另一端几经终止了那个方向的数据传送 发送F I N通常是应用层进行关闭的结果。
收到一个F I N只意味着在这一方向上没有数据流动
  * 一个 T C P连接在收到一个F I N后仍能发送数据。而这对利用半关闭的应用来说是可能的很少的 T C P会使用
  * 半关闭首先进行关闭的一方（即发送第一个 FIN）将执行主动关闭，而另一方（收到这个 F I N）执行被动关闭 通常一方完成主动关闭而另一方完成被动关闭
  * 连接通常是由客户端发起的 这样第一个SYN从客户传到服务器每一端都能主动关闭这个连接（即首先发送 F I N）
  

* 正常的tcpdump输出
  * 对所有的数值很大的序号进行排序是很麻烦的，因此默认情况下 t c p d u m p只在显示S Y N
报文段时显示完整的序号，而对其后的序号则显示它们与初始序号的相对偏移值（为了得到图1 8 - 1的输出显示必须加上- S选项）。

* 接建立的超时
  * 有很多情况导致无法建立连接。一种情况是服务器主机没有处于正常状态 断开服务器主机的电缆线，然后向它发出t e l n e t命令

* 最大报文段长度（M S S）
  * 表示T C P传往另一端的最大块数据的长度。当一个连接建立时，
连接的双方都要通告各自的 M S S。我们已经见过M S S都是1 0 2 4。这导致I P数据报通常是4 0字
节长：2 0字节的T C P首部和2 0字节的I P首部。
  * 它并不是任何条件下都可协商。当建立一个连接时，每一方都有用于通告它期望接收的 M S S选项（M S S选项只能出现在S Y N报文段中）。如
果一方不接收来自另一方的 M S S值，则M S S就定为默认值5 3 6字节（这个默认值允许2 0字节的
I P首部和2 0字节的T C P首部以适合5 7 6字节I P数据报)。
  * 一般，如果没有分段发生， M S S还是越大越好报文段越大允许每个报文段传送的数据就越多，
 相对 I P和T C P首部有更高的网络利用率。当 T C P发送一个S Y N时，或者是因为一个本地应用进程想发起一个连接，或
者是因为另一端的主机收到了一个连接请求，它能将 M S S值设置为外出接口上的 M T U长度减去固定的I P首部和T C P首部长度
对于一个以太网M S S值可达1 4 6 0字节。使用IEEE 802.3的封装，它的M S S可达1 4 5 2字节

* TCP的半关闭
  * T C P提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力称为半关闭
  * 编程接口必须为应用程序提供一种方式来说明“我已经完成了数据传送，因此发送一个文件结束（ F I N）给另一端
  但我还想接收另一端发来的数据，直到它给我发来文件结束（F I N）
如果应用程序不调用c l o s e而调用s h u t d o w n，且第2个参数值为1，则插口的A P I支持
半关闭。然而，大多数的应用程序通过调用close终止两个方向的连接

* 图1 8 - 1 0显示了一个半关闭的典型例
  * 让左方的客户端开始半关闭，当然也可以由另一端开始。开始的两个报文段和
图1 8 - 4是相同的：初始端发出的 F I N，接着是另一端对这个 F I N的A C K报文段。但后面就和图1 8 - 4不同，因为接收半关闭的
一方仍能发送数据。
  * 只显示一个数据报文段和一个A C K报文段，但可能发送许多数据报文段当收到半关闭的一端在完成它的数据传送后，将发送一个F I N关闭这个方向的连接
  这将传送一个文件结束符给发起这个半关闭的应用进程对第二个 F I N进行确认后，这个连接便彻底关闭了执行这个T C P连接的半关闭
  接着s o r t服务器在它的标准输入（这个 T C P连接）上收到一个文件结束符，对数据进行排序并将结果写在它的标准输出上
  （T C P连接 rsh客户端继续接收来自T C P连接另一端的数据，并将排序的文件复制到它的标准输出上

* TCP的状态变迁图
  * 第二点是两个导致进入E S TA B L I S H -E D状态的变迁对应打开一个连接
  两个导致从E S TA B L I S H E D状态离开的变迁对应关闭一个连接E S TA B L I S H E D状态是连接双方能够进行双向数据传递的状态
  * RFC 793中 的 最 初 描述 一 致 C L O S E D状态不是一个真正的状态，而是这个状态图的假想起点和终点
  从L I S T E N到S Y N _ S E N T的变迁是正确的，但伯克利版的T C P软件并不支持它。
  只有当S Y N _ R C V D状态是从L I S T E N状态（正常情况）进入，而不是从 S Y N _ S E N T状态（同时打开）进入时，从 S Y N _ R C V D回到L I S T E N的状态变迁才是有效的。这意味着如果我们执行被动关闭（进入L I S T E N），收到一个S Y N，发送一个带A C K的S Y N（进入S Y N _ R C V D），然后收到一个R S T，而不是一个A C K，便又回到L I S T E N状态并等待另一个连接请求的到来。
  * 图1 8 - 1 3显示了在正常的T C P连接的建立与终止过程中，客户与服务器所经历的不同状态。
它是图1 8 - 3的再现，不同的是仅显示了一些状态。假定在图1 8 - 1 3中左边的客户执行主动打开，而右边的服务器执行被动打开。尽管图中显
示出由客户端执行主动关闭，但和早前我们提到的一样，另一端也能执行主动关闭。

* 2MSL等待状态
  * T I M E _ WA I T状态也称为2 M S L等待状态。每个具体 T C P实现必须选择一个报文段最大生
存时间M S L（Maximum Segment Lifetime） 任何报文段被丢弃前在网络内的最长时间这个时间是有限的，因为 T C P报文段以I P数据报在网络内传输，而I P数据报则有限制其生存时间的T T L字段
  * RFC 793 [Postel 1981c] 指出MSL为2分钟 实现中的常用值是30秒，1分钟，或2分钟。
  * 该连接必须在TIME _ WA I T状态停留的时间为 2倍的M S L让T C P再次发送最后的A C K以防这个A C K丢失（另一端超时并重发最后的F I N）


* 复位报文段
  * T C P首部中的R S T比特是用于“复位”的。一般说来，无论何时一个报文段发往基准的连接（referenced connection）出现错误
    T C P都会发出一个复位报文段（这里提到的“基准的连接”是指由目的 I P地址和目的端口号以及源 I P地址和源端口号指明的连接。
RFC 793称之为插口
  * 到不存在的端口的连接请求
    * 产生复位的一种常见情况是当连接请求到达时，目的端口没有进程正在听,对于 U D P当一个数据报到达目的端口时，该端口没在使用，它将产生一个I C M P端口不可达的信息。而T C P则使用复位。
  *  A C K比特在到达的报文段中没有被设置为 1，复位报文段中的序号被置为 0，确认序号被置为进入的I S N加上数据字节数。尽管在到达的报文段中没有真正的数据，但 S Y N比特从逻辑上占用了1字节的序号空间；这个例子中复位报文段中确认序号被置为 I S N与数据长度（0）、S Y N比特所占的1的总和

* 检测半打开连接
  * 如果一方已经关闭或异常终止连接而另一方却还不知道 这样的 T C P连接称为半打开（H a l f - O p e n）的。任何一端的主机异常都可能导致发生这种情况。只要不打算在半打开连接上传输数据，仍处于连接状态的一方就不会检测另一方已经出现异常。
  * 半打开连接的另一个常见原因是当客户主机突然掉电而不是正常的结束客户应用程序后再关机,这可能发生在使用 P C机作为Te l n e t的客户主机上，例如，用户在一天工作结束时关闭P C机的电源。
  * 关闭P C机电源时，如果已不再有要向服务器发送的数据，服务器将永远不知道客户程序已经消失了
  当用户在第二天到来时，打开 P C机，并启动新的Telnet客户程序在服务器主机上会启动一个新的服务器程序导致服务器主机中产生许多半打开的T C P连接

* 同时打开
  * 两个应用程序同时彼此执行主动打开的情况是可能的，尽管发生的可能性极小。每一方
必须发送一个S Y N，且这些S Y N必须传递给对方。这需要每一方使用一个对方熟知的端口作
为本地端口 这又称为同时打开（ simultaneous open）。
  * 处理同时打开，对于同时打开它仅建立一条连接而不是两条连接（其他的协议族，最突出的是O S I运输层，种情况下将建立两条连接而不是一条连接当出现同时打开的情况时，状态变迁与图 1 8 - 1 3所示的不同。
  * 两端几乎在同时发送 S Y N，并进入S Y N _ S E N T状态。当每一端收到S Y N时，状态变为S Y N _ R C V D（如图1 8 - 1 2），同时它们都再发S Y N并对收到的S Y N进行确认。当双方都收到 S Y N及相应的A C K时，状态都变迁为E S TA B L I S H E D。图1 8 - 1 7显示了这些状态变迁过程。

* 同时关闭
  * （通常但不总是客户方）发送第一个 F I N执行主动关闭。双方都执
行主动关闭也是可能的，T C P协议也允许这样的同时关闭（simultaneous close）
在图1 8 - 1 2中，当应用层发出关闭命令时，两端均从 E S TA B L I S H E D变为F I N _ WA I T _ 1
这将导致双方各发送一个 F I N，两个F I N经过网络传送后分别到达另一端。收到 F I N后，状态由F I N _ WA I T _ 1变迁到C L O S I N G，并发送最后的 A C K。当收到最后的 A C K时，状态变化为T I M E _ WAIT

* TCP 选项
  * T C P首部可以包含选项部分（图 1 7 - 2）。仅在最初的T C P规范中定义的选项是选项表结束、
无操作和最大报文段长度。在我们的例子中，几乎每个 S Y N报文段中我们都遇到过M S S选项。
新的R F C，主要是RFC 1323 [Jacobson, Braden和Borman 1992]，定义了新的T C P选项
  * 每个选项的开始是1字节k i n d字段，说明选项的类型。k i n d字段为0和1的选项仅占1个字节。
其他的选项在k i n d字节后还有l e n字节。它说明的长度是指总长度，包括 k i n d字节和l e n字节。
设置无操作选项的原因在于允许发方填充字段为 4字节的倍数。如果我们使用4 . 4 B S D系统
进行初始化T C P连接，t c p d u m p将在初始的S Y N上显示下面T C P选项：
<mss 512, nop, wscale 0, nop, nop, timestamp 146647 0>
M S S选项设置为5 1 2，后面是N O P，接着是窗口扩大选项。第一个 N O P用来将窗口扩大选项填
充为4字节的边界。同样， 1 0字节的时间戳选项放在两个 N O P后，占1 2字节，同时使两个 4字
节的时间戳满足4字节边界。

* TCP 服务器的设计
  * 多数的T C P服务器进程是并发的。当一个新的连接请求到达服务器时，
服务器接受这个请求，并调用一个新进程来处理这个新的客户请求。不同的操作系统使用不
同的技术来调用新的服务器进程。在 U n i x系统下，常用的技术是使用 f o r k函数来创建新的进
程。如果系统支持，也可使用轻型进程，即线程

* TCP服务器端口号
  * 使用 n e t s t a t命令来观察 Te l n e t服务器
  *  a标志将显示网络中的所有主机端，而不仅仅是处于 E S TA B L I S H E D的主机端。- n标志
将以点分十进制的形式显示 I P地址，而不是通过 D N S将地址转化为主机名，同时还要求显示
端口号（例如为 2 3）而不是服务名称（如 Te l n e t）。
  * -f inet选项则仅要求显示使用 T C P或U D P的主机。
  * 端口为2 3的第1行表示处于E S TABLISHED 状态的连接。另外还显示了这个连接的本地 I P
地址、本地端口号、远端 I P地址和远端端口号。 本地I P地址为该连接请求到达的接口（以太
网接口，1 4 0 . 2 5 2 . 1 3 . 3 3）。
  * 处于L I S T E N状态的服务器进程仍然存在。这个服务器进程是当前 Te l n e t服务器用于接收
其他的连接请求。当传入的连接请求到达并被接收时，系统内核中的 T C P模块就创建一个处
于E S TA B L I S H E D状态的进程。注意处于 E S TA B L I S H E D状态的连接的端口不会变化：
也是2 3，与处于L I S T E N状态的进程相同。

* 限定的本地IP地址
  * 当服务器不能任选其本地 I P地址而必须使用特定的 I P地址时的情况。如果我
们为s o c k程序指明一个I P地址（或主机名），并将它作为服务器，那么该 I P地址就成为处于
L I S T E N服务器的本地I P地址

* 限定的远端IP地址
  * U D P服务器通常在指定I P本地地址和本地端口外，还能指定远端 I P
地址和远端端口。RFC 793中显示的接口函数允许一个服务器在执行被动打开时，可指明远端
插口（等待一个特定的客户执行主动打开），也可不指明远端插口（等待任何客户）。
遗憾的是，大多数A P I都不支持这么做。服务器必须不指明远端插口，而等待连接请求的
到来，然后检查客户端的I P地址和端口号
  * T C P服务器进行连接时三种类型的地址绑定。在三种情况中， l p o r t是服务
器的熟知端口，而l o c a l I P必须是一个本地接口的I P地址。表中行的顺序正是T C P模块在收到一
个连接请求时确定本地地址的顺序。最常使用的绑定（第 1行，如果支持的话）将最先尝试，
最不常用的（最后一行两端的I P地址都没有制定）

* 带宽时延乘积
  * 计算通道的容量为： c a p a c i t y (bit) = b a n d w i d t h (b/s) × ro u n d-trip time ( s )
  * 带宽时延乘积。这个值依赖于网络速度和两端的 RT T，可以有很大的变动。例如，
一条穿越美国（RT T约为60 ms）的T 1的电话线路（1 544 000 b/s）的带宽时延乘积为11 580字
节。对于2 0 . 4节中讨论的缓存大小而言，这个结果是合理的。但是一条穿越美国的 T 3电话线路
（45 000 000 b/s）的带宽时延乘积则为337 500字节，这个数值超过了最大所允许的T C P通告窗
口的大小（6 5 5 3 5字节）。在2 4 . 4节我们将讨论能够避免当前T C P限制的新的T C P窗口大小选项。
  * 假定网络速率已经加倍，使得我们能够只使用上面一半的时间来发送
4个报文段。这样，该管道的容量再次加倍（假定该图的上半部分与下半部分中的报文段具有
同样大小，即具有相同的比特数）。

* 拥塞
  * 当数据到达一一个大的管道（如一个快速局域网）并向一个较小的管道（如一个较慢的广发送时便会发生拥塞
  当多个输入流到达一个路由器，而路由器的输出流小于这些输入流的总和时也会发生拥塞。
  * A C K之间的间隔与在最慢链路上的一致。假定瓶颈路由器具有足够的容纳这 2 0个分组的缓存。
  如果这个不能保证，就会引起路由器丢弃分组

* 紧急方式
  * T C P提供了“紧急方式 ( u rgent mode)”，它使一端可以告诉另一端有些具有某种方式的
“紧急数据”已经放置在普通的数据流中。另一端被通知这个紧急数据已被放置在普通数据流
中，由接收方决定如何处理。
可以通过设置T C P首部（图1 7 - 2）中的两个字段来发出这种从一端到另一端的紧急数据
已经被放置在数据流中的通知。 U R G比特被置1，并且一个1 6 b i t的紧急指针被置为一个正的
偏移量，该偏移量必须与 T C P首部中的序号字段相加，以便得出紧急数据的最后一个字节的序号。
  * T C P本身对紧急数据知之甚少。没有办法指明紧急数据从数据流的何处开始。 T C P通过连
接传送的唯一信息就是紧急方式已经开始（ T C P首部中的U R G比特）和指向紧急数据最后一
个字节的指针。其他的事情留给应用程序去处理。
不幸的是，许多实现不正确地称 T C P的紧急方式为带外数据(out-of-band data)。如果一个
应用程序确实需要一个独立的带外信道，第二个 T C P连接是达到这个目的的最简单的方法
（许多运输层确实提供许多人认为的那种真正的带外数据：使用同一个连接的独立的逻辑数据
通道作为正常的数据通道。这是T C P所没有提供的）。

## TCP的超时与重传
> T C P通过在发送时设置一个定时器来解决这种问题。如果当定时器溢出
时还没有收到确认，它就重传该数据。对任何实现而言，关键之处就在于超时和重传的策略，
即怎样决定超时间隔和如何确定重传的频率。

* 重传机制
  * I C M P端口不能到达的例子中，看到T F T P客户使用U D P实现了一个简单的超时和重传机制：假定 5秒是一个适当的时间间隔，
  并每隔5秒进行重传
  * 在向一个不存在的主机发送 A R P的例子中（第4 . 5节），我们看到
当T C P试图建立连接的时候，在每个重传之间使用一个较长的时延来重传 S Y N。
  * 每个连接，T C P管理4个不同的定时器。
    1. 重传定时器使用于当希望收到另一端的确认。在本章我们将详细讨论这个定时器以及
一些相关的问题，如拥塞避免。
    2. 坚持( p e r s i s t )定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口。第
  3. 保活( k e e p a l i v e )定时器可检测到一个空闲连接的另一端何时崩溃或重启。
  4. 2MSL定时器测量一个连接处于 T I M E _ WA I T状态的时间。

* 超时与重传的简单例子
  * 首先观察T C P所使用的重传机制，我们将建立一个连接，发送一些分组来证明一切正常，
然后拔掉电缆，发送更多的数据，再观察 T C P的行为。
  * 检查连续重传之间不同的时间差，它们取整后分别为 1、3、6、12、24、4 8和多个6 4
秒。在本章的后面，我们将看到当第一次发送后所设置的超时时间实际上为 1 . 5秒（它在首次
发送后的1.0136秒而不是精确的1 . 5秒后，此后该时间在每次重传时增加1倍并直至6 4秒。
  * 倍乘关系被称为“指数退避 (exponential backoff )”。可以将该例子与6 . 5节中的T F T P
例子比较，在那里每次重传总是在前一次的 5秒后发生。
首次分组传输（第6行，24.480秒）与复位信号传输（第19行566.488秒）之间的时间差
约为9分钟，该时间在目前的TCP实现中是不可变的。


* 往返时间测量
  * T C P超时与重传中最重要的部分就是对一个给定连接的往返时间（ RT T）的测量。由于路
由器和网络流量均会变化，因此我们认为这个时间可能经常会发生变化， T C P应该跟踪这些
变化并相应地改变其超时时间。
  * 首先T C P必须测量在发送一个带有特别序号的字节和接收到包含该字节的确认之间的
RT T 数据报文段和 A C K之间通常并没有一一对应的关系发送方可以测量到的一个 RT T
在发送报文段4（第1 ~ 1 0 2 4字节）和接收报文段7（对1 ~ 1 0 2 4字节的A C K）之间的时间，用M表示所测量到的RT T。
  *  P规范使T C P使用低通过滤器来更新一个被平滑的 RT T估计器（记为O）。
    * R← R+ ( 1- )M
  * 推荐值为 0 . 9的平滑因子。每次进行新测量的时候，这个被平滑的 RT T将得到
更新。每个新估计的9 0％来自前一个估计，而1 0 %则取自新的测量。
该算法在给定这个随RT T的变化而变化的平滑因子的条件下， RFC 793推荐的重传超时时
间RTO（Retransmission Ti m e O u t）的值应该设置为
    * RTO = R
  * 这里的 是一个推荐值为2的时延离散因子。
  
* 往返时间RTT的例子
  * 使用s o c k程序和如下的命令来将32768字节的数据从主机slip发送到主机vangogh.cs.b e r k e l e y . e d u上的丢弃服务。
    * slip % sock -D -i -n32 vangogh.cs.berkeley.edu discard
    * 在扉页前图中，可以看到 s l i p通过两个 S L I P链路与1 4 0 . 2 5 2 . 1以太网相连
    并从这里通过Internet到达目的地。通过使用两个 9600 b/s的S L I P链路，我们期望能够得到一些可测量的时延
  * 该命令执行3 2个写1 0 2 4字节的操作。由于s l i p和b s d i之间的M T U为2 9 6字节，因此这些
操作会产生1 2 8个报文段，每个报文段包含 2 5 6字节的用户数据。整个传输过程的时间约为 4 5
秒，我们观察到了一个超时和三次重传。
当该传输过程进行时，我们在 s l i p上使用t c p d u m p来截获所有的发送和接收的报文段，
并通过使用 - D选项来打开插口排错功能（见 A . 6节），这样便可以通过运行一个修改后的
t r p t( 8 )程序来打印出连接控制块中与RT T、慢启动及拥塞避免等有关的多个变量。

* 往返时间RTT的测量
  * 在图2 1 - 2左边的时间轴上有三个括号，它们表明为进行RT T计算对哪些报文段进行了计时，
并不是所有的报文段都被计时。
  * 大多数源于伯克利的T C P实现在任何时候对每个连接仅测量一次 RT T值。在发送一个报文
段时，如果给定连接的定时器已经被使用，则该报文段不被计时。
  * 在每次调用 500 ms的T C P的定时器例程时，就增加一个计数器来完成计时。这意味着，
如果一个报文段的确认在它发送 550 ms后到达，则该报文段的往返时间 RT T将是1个滴答（即
500 ms）或是2个滴答(即1000 ms)。
  * 对每个连接而言，除了这个滴答计数器，报文段中数据的起始序号也被记录下来。当收
到一个包含这个序号的确认后，该定时器就被关闭。如果 A C K到达时数据没有被重传，则被
平滑的RT T和被平滑的均值偏差将基于这个新测量进行更新。
  * 对每个连接而言，除了这个滴答计数器，报文段中数据的起始序号也被记录下来。当收
到一个包含这个序号的确认后，该定时器就被关闭。如果 A C K到达时数据没有被重传，则被
平滑的RT T和被平滑的均值偏差将基于这个新测量进行更新。
  * 定时器在发送报文段 6时再次被启动，并在 1 . 0 1 5秒后接收到它的确认（报文段 1 0）时终
止 测量到的RT T是2个滴答。报文段7和9不能被计时，因为定时器已经被使用。

* RTT估计器的计算
  * RT T估计器（平滑的RT T和平滑的均值偏差）是如何被初始化和更新，以及每个重传超时是怎样计算的。
  * 变量A和D分别被初始化为0和3秒。初始的重传超时使用下面的公式进行计算（因子2D只在这个初始化计算中使用。正如前面提到的，以后使用4D和A相加来计算RTO）这就是传输初始S Y N所使用的RTO 结果是这个初始S Y N丢失了，然后超时并引起了重传。图 2 1 - 5给出了t c p d u m p输出文件中的前4行。
  * 应用于RTO的指数退避取为 1 2。由于这是第1次超时，我们使用倍数 2，因此下一个超时时间取值为2 4秒。再下一个超时时间的倍数为 4，得出值为4 8秒

* 拥塞
  * 可以立即看到图2 1 - 6中发生在时刻1 0，1 4和2 1附近的3个重传。我们还可以看到在这 3个
点中只进行了一次报文段的重传，因为只有一个点下垂低于向上的斜率。
仔细检查一下这几个下垂点中的第 1个点（在1 0秒标记处的附近）。整理t c p d u m p的输出
结果可以得到图2 1 - 7。
在这个图中，除了下面将要讨论的报文段 7 2，已经去掉了其他所有的窗口通告。主机
s l i p总是通告窗口大小为 4 0 9 6，而主机v a n g o g h则通告窗口为8 1 9 2。该图中报文段的编号
可以看作是图2 1 - 2的延续，在那里报文段的编号从 1开始。与图2 1 - 2一样，报文段根据在 s l i p
上发送和接收的顺序进行编号， t c p d u m p在主机s l i p上运行。我们还去掉了一些与讨论无
  * 目前T C P尚无办法告诉对方缺少一个报文段，也无法确认失序数据。此时主机 v a n g o g h
所能够做的就是继续发送确认序号为 6 6 5 7的A C K。
当缺少的报文段（报文段 6 3）到达时，接收方T C P在其缓存中保存第6 6 5 7 ~ 8 9 6 0字节的数
据，并将这2 3 0 4字节的数据交给用户进程。所有这些数据在报文段 7 2中进行确认。请注意此
时该A C K通告窗口大小为5 8 8 8（8 1 9 2-2 3 0 4），这是因为用户进程没有机会读取这些已准备好
的2 3 0 4字节的数据。
如果仔细检查图21-6 中t c p d u m p的输出中第1 4和2 1秒附近的下垂点，我们会看到它们也
是由于收到了3个重复A C K引起的，这表明一个分组已经丢失。在这些例子中只有一个分组被
重传。


* 拥塞避免算法
  * 慢启动算法是在一个连接上发起数据流的方法，但有时我们会达到中间路由器的极限，此时分组将被丢弃
  拥塞避免算法是一种处理丢失分组的方法。该方法的具体描述见 [Jacobson 1988]。
  * 假定由于分组受到损坏引起的丢失是非常少的（远小于 1 %），因此分组丢失就意
味着在源主机和目的主机之间的某处网络上发生了拥塞。有两种分组丢失的指示：发生超时
和接收到重复的确认（我们在 2 1 . 5节看到这种现象。如果使用超时作为拥塞指示，则需要使
用一个好的RT T算法，正如在2 1 . 3节中描述的那样）。
  * 拥塞避免算法和慢启动算法是两个目的不同、独立的算法。但是当拥塞发生时，我们希
望降低分组进入网络的传输速率，于是可以调用慢启动来作到这一点。在实际中这两个算法
通常在一起实现。
  * 拥塞避免算法和慢启动算法需要对每个连接维持两个变量：一个拥塞窗口 c w n d和一个慢
启动门限s s t h re s h。这样得到的算法的工作过程如下：
    1. 对一个给定的连接，初始化c w n d为1个报文段，s s t h re s h为6 5 5 3 5个字节。
    2. TCP输出例程的输出不能超过 c w n d和接收方通告窗口的大小。拥塞避免是发送方使用
的流量控制，而通告窗口则是接收方进行的流量控制。前者是发送方感受到的网络拥塞的估
计，而后者则与接收方在该连接上的可用缓存大小有关。
    3. 当拥塞发生时（超时或收到重复确认），s s t h re s h被设置为当前窗口大小的一半（cwnd和接收方通告窗口大小的最小值，但最少为 2个报文段）
如果是超时引起了拥塞，则c w n d被设置为1个报文段（这就是慢启动）。
    4. 当新的数据被对方确认时，就增加 c w n d，但增加的方法依赖于我们是否正在进行慢启
动或拥塞避免。如果 c w n d小于或等于s s t h re s h，则正在进行慢启动，否则正在进行拥塞避免。
慢启动一直持续到我们回到当拥塞发生时所处位置的半时候才停止然后转为执行拥塞避免。

* 快速重传与快速恢复算法
  * 拥塞避免算法的修改建议1 9 9 0年提出 [Jacobson 1990b]在收到一个失序的报文段时， T C P立即需要产生一个 A C K
（一个重复的A C K）。这个重复的A C K不应该被迟延。该重复的 A C K的目的在于让对方知道收到一个失序的报文段，并告诉对方自己希望收到的序号。
  * 快速启动算法：不知道一个重复的 A C K是由一个丢失的报文段引起的，由于仅仅出现了几个报文段的重新排序
  因此我们等待少量重复的 A C K到来。假如这只是一些报文段的重新排序，则在重新排序的报文段被处理并产生一个新的 A C K之前
  只可能产生1 ~ 2个重复的A C K。如果一连串收到 3个或3个以上的重复A C K，就非常可能是一个报文段丢失了于是我们就重传丢失的数据报文段，
  无需等待超时定时器溢出。这就是快速重传算法,下来执行的不是慢启动算法而是拥塞避免算法。
  * 在图 21-7 中可以看到在收到3个重复的A C K之后没有执行慢启动。相反，发送方进行重传，
  接着在收到重传的A C K以前，发送了3个新的数据的报文段
  没有执行慢启动的原因是由于收到重复的 A C K不仅仅告诉我们一个分组丢失了。
  接收方只有在收到另一个报文段时才会产生重复的 A C K，而该报文段已经离开了网络并进入了接收方的缓存。
  在收发两端之间仍然有流动的数据不执行慢启动来突然减少数据流。
  * 这个算法通常按如下过程进行实现：
    1. 当收到第3个重复的ACK时，将ssthresh设置为当前拥塞窗口 cwnd的一半。重传丢失的
报文段。设置cwnd为s s t h re s h加上3倍的报文段大小。
    2. 每次收到另一个重复的 A C K时，c w n d增加1个报文段大小并发送 1个分组 如果新的
c w n d允许发送
    3. 当下一个确认新数据的A C K到达时，设置c w n d为s s t h re s h（在第1步中设置的值）。这个
A C K应该是在进行重传后的一个往返时间内对步骤 1中重传的确认。另外，这个 A C K也应该
是对丢失的分组和收到的第 1个重复的A C K之间的所有中间报文段的确认。这一步采用的是拥塞避免，因为当分组丢失时我们将当前的速率减半

* 按每条路由进行度量
  * 较新的T C P实现在路由表项中维持许多我们在本章已经介绍过的指标。当一个 T C P连接关
闭时，如果已经发送了足够多的数据来获得有意义统计资料，且目的结点的路由表项不是一
个默认的表项，那么下列信息就保存在路由表项中以备下次使用：被平滑的 RT T、被平滑的
均值偏差以及慢启动门限。所谓“足够多的数据”是指 1 6个窗口的数据，这样就可得到 1 6个
RTT采样，从而使被平滑的RT T过滤器能够集中在正确结果的5 %以内。
  * 管理员可以使用 r o u t e ( 8 )命令来设置给定路由的度量：前一段中给出的三个指标以
及M T、输出的带宽时延乘积（见第2 0 . 7节）和输入的带宽时延乘积。
当建立一个新的连接时，不论是主动还是被动，如果该连接将要使用的路由表项已经有
这些度量的值，则用这些度量来对相应的变量进行初始化

* ICMP的差错
  * T C P是怎样处理一个给定的连接返回的 I C M P的差错。T C P能够遇到的最常见的I C M P差错就是源站抑制、主机不可达和网络不可达。
  当前基于伯克利的实现对这些错误的处理是：
    * 一个接收到的源站抑制引起拥塞窗口 c w n d被置为1个报文段大小来发起慢启动，但是慢启动门限ssthesh没有变化，所以窗口将打开直至它或者开放了所有的通路（受窗口大小和往返时间的限制）或者发生了拥塞
    * 一个接收到的主机不可达或网络不可达实际上都被忽略，因为这两个差错都被认为是短暂现象
    由于中间路由器被关闭而导致选路协议要花费数分钟才能稳定到另一个替换路由。在这个过程中就可能发生这两个 I C M P差错中的一个，但是连接
并不必被关闭 相反 T C P试图发送引起该差错的数据，尽管最终有可能会超时 当前基于伯克利的实现记录发生的
I C M P差错，如果连接超时， I C M P差错被转换为一个更合适的的差错码而不是“连接超时”

* 重新分组
  * T C P超时并重传时，它不一定要重传同样的报文段。相反， T C P允许进行重新分组而发
送一个较大的报文段，这将有助于提高性能（较大的报文段不能够超过接收方声明的M S S）
  * 在协议中这是允许的，因为 T C P是使用字节序号而不是报文段序号来进行识别它所要发送的数据和进行确认。
  * 使用 s o c k程序连接到丢弃服务器并键入一行。接着拔掉以太网电缆并再键入一行
  当这一行被重传时，键入第 3行。我们预期下一个重传包含第2次和第3次键入的数据。

## TCP的坚持定时器
> 如果一个确认丢失了，则双方就有可能因为等待对方而使连接终止：接收方等待接收数据（因为它已经向发送方通告了一个非 0的窗口）
而发送方在等待允许它继续发送数据的窗口更新。为防止这种死锁情况的发生，发送方使用一个坚持定时器 (persist timer)来周期性地向接收方查询
以便发现窗口是否已增大。这些从发送方发出的报文段称为窗口探查 ( w i n d o wp r o b e ) 窗口探查和坚持定时器
还将讨论与坚持定时器有关的糊涂窗口综合症。


