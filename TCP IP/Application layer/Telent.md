# Telnet和Rlogin：远程登录
 > 远程登录（Remote Login）是I n t e r n e t上最广泛的应用之一。我们可以先登录（即注册）
到一台主机然后再通过网络远程登录到任何其他一台网络主机上去，而不需要为每一台主机
连接一个硬件终端（当然必须有登录帐号）。

* T C P / I P网络上，有两种应用提供远程登录功能。
  1. Te l n e t是标准的提供远程登录功能的应用，几乎每个 T C P / I P的实现都提供这个功能。它
能够运行在不同操作系统的主机之间。Te l n e t通过客户进程和服务器进程之间的选项协商机制，
从而确定通信双方可以提供的功能特性。
  2. Rlogin起源于伯克利Unix，开始它只能工作在Unix系统之间，现在已经可以在其他操作系统上运行。
  3. 仅仅使用了一条T C P连接。由于客户进程必须多次和服务器进程进行通信（反之亦然），
这就必然需要某些方法，来描绘在连接上传输的命令和用户数据。我们在后面的内容中会介
绍Te l n e t和R l o g i n是如何处理这个问题的。
  4. 终端驱动进程和伪终端驱动进程框了起来在T C P / I P实现中，虚线框的内容一般是操作系统内核的一部分。
Te l n e t客户进程和服务器进程一般只是属于用户应用程序。
  5. 把服务器进程的登录外壳进程画出来的目的是为了说明：当我们想登录到系统的时候，必须要有一个帐号，Te l n e t和R l o g i n都是如此。

* Rlogin协议
  * RFC 1282 [Kantor 1991]详细说明了R l o g i n协议。类似于选路信息协议（R I P）的RFC
 R l o g i n用了许多年后才发布的。 [Stevens 1990]的第1 5章介绍了远程登录的客户进程及服务
器进程端的编程，并且给出了 R l o g i n的客户进程及服务器进程的完整源代码。
[ C o m e r和Stevens 1993]的第2 5章和第2 6章给出了Te l n e t的客户进程的实现细节和源代码。

* 应用进程的启动
  * R l o g i n的客户进程和服务器进程使用一个 T C P连接。当普通的T C P连接建立完毕之后，客
户进程和服务器进程之间将发生下面所述的动作
  1. 客户进程给服务器进程发送4个字符串：
  a. 一个字节的0；
  b. 用户登录进客户进程主机的登录名，以一个字节的0结束；
  c. 登录服务器进程端主机的登录名，以一个字节的0结束；
  d. 用户终端类型名，紧跟一个正斜杠“/”，然后是终端速率，以一个字节的0结束。在这里需要两个登录名字，这是因为用户登录客户和服务器的名称有可能不一样。由于大多满屏应用程序需要知道终端类型，所以终端类型也必须发送到服务器进程发送终端速率的原因是因为有些应用随着速率的改变，它的操作也有所变化。例如 vi编辑器，当速率比较小的时候，它的工作窗口也变小。所以它不能永远保持同样大小的窗口。
 2. 服务器进程返回一个字节的0。
 3. 服务器进程可以选择是否要求用户输入口令。这个步骤的数据交互没有什么特别的协议，而被当作是普通的数据进行传输。
  服务器进程给客户进程发送一个字符串（显示在客户进程的屏幕上），通常是password: 。如果在一定的限定时间内（通常是 6 0秒）
客户进程没有输入口令，服务器进程将关闭该连接。通常可以在服务器进程的主目录(home directory)下生成一个文件（通常叫 . r h o s t s），该
文件的某些行记录了一个主机名和用户名。如果从该文件中已经记录的主机上用已经记录的用户名进行登录，服务器进程将不提示我们输入口令。但是很多关于安全性的
文献，如[Curry 1992]，强烈建议不要采用这种方法，因为这存在安全漏洞。
  * 如果提示输入口令，那么我们输入的口令将以明文的形式发送到服务器进程键入的每个字符都是以明文的格式传输的。所以某人只要能够截取网络上的原始传输的分组，他就可以截获用户口令。针对这个问题，新版本的 Rlogin客户程序，例如4 . 4 B S D版本的客户程序，第一次采用了 Kerberos安全模型。Kerberos安全模型可以避免用户口令以明文的形式在网络上传输。当然，这要求服务器进程也支持 K e r b e r o s（[Curry 1992]详细描述了Kerber os安全模型）。
  4. 服务器进程通常要给客户进程发送请求，询问终端的窗口大小客户进程每次给服务器进程发送一个字节的内容，并且接收服务器进程的所有返回信息。
同样我们也采用了Nagle算法该算法可以保证在速率较低的网络上，若干输入字节以单个 T C P报文段传输。操作其实很简单：用户
键入的所有东西被发送到服务器，服务器发送给客户的任何信息返回到用户的屏幕上。
服务器和客户之间还可以互相发送命令。
  
* 流量控制
  * 默认情况下，流量控制是由 Rlogin的客户进程完成的。客户进程能够识别用户键入的
STOP和START的ASCII字符（C o n t r o l ＿ S和Control＿ Q），并且终止或启动终端的输出。
  * 如果不是这样，每次我们为终止终端输出而键入的 C o n t r o l _ S字符将沿网络传输到服务器
进程，这时服务器进程将停止往网络上写数据。但是在写操作终止之前，服务器进程可能已
经往网络上写了一窗口的输出数据。也就是说，在输出停止之前，成千上万的数据字节还将
对于一个交互式用户来讲，Control_S字符的响应延时是较大的。
  * 服务器的应用程序需要解释输入的每个字节，但又不想让客户对它的输入内容进行处理
  例如对控制字符如 Control_S和Control _ Q进行特殊处理（emacs编辑器就是这样的一个例子，它把Control _ S和Control _ C作为自己的命令）解决这个问题的办法就是由服务器告诉客户是否要进行流量控制


* 客户的中断键
  * 中断服务器正在运行的进程而键入一个中断字符时（通常是 D E L E T E或C o n t r o l _ C）
  会发生和流量控制相同的问题,在一条T C P连接的管道上，从服务器进程向客户进程正在发送大量的数据
  而客户进程同时在向服务器进程传输中断字符。而我们的本意是要中断字符尽快终止某个进程，使屏幕上不再有任何响应输出。
  * 在流量控制和中断键这两种情况中，流量控制机制很少终止客户进程到服务器进程的数据流。仅仅包含我们键入的字符。所以对于从客户输出到服务器的特殊输入字符（C o n t r o l _ S和中断字符）不需要采用T C P的紧急方式（u rgent mode）。


* 窗口大小的改变
  * 当应用程序在运行的时候，我们还可以动态地改变窗口的大小。
  一些应用程序（典型的如那些操作整个窗口的应用程序，如全屏编辑器）需要知道窗口大小的变化，
  多数U n i x系统提供这种功能，可以告诉应用程序关于窗口大小的变化。
  * 对于远程登录这种情况，窗口大小的变化发生在客户端，而运行在服务器端的应用程序
  需要知道窗口大小变化。所以 R l o g i n的客户需要采用某些方法来通知服务器窗口大小变化的情况以及新窗口的大小

* 服务器到客户的命令
  * R l o g i n服务器进程可以发送给客户进程的 4条命令。当只有一条T C P连接可供使用，所以服务器进程必须给这些命令字节做标记
  使得客户进程可以从数据流中识别出这些是命令，而不是显示在终端上。将使用 TCP的紧急方式
  * 当服务器要给客户发送命令时，服务器就进入紧急方式，并且把命令放在紧急数据的最后一个字节中。
  当客户进程收到这个紧急方式通知时，它从连接上读取数据并且保存起来，直到读到命令字节（即紧急数据的最后一个字节）。
  客户进程根据读到的命令，再决定对于所读到并保存起来的数据是显示在终端上还是丢弃它。
  * 采用T C P紧急方式发送这些命令的一个原因是第一个命令（“清仓输出(flush output)”）需要立即发送给客户
  即使服务器到客户的数据流被窗口流量控制所终止。这种情况下，即服


* 客户的转义符
  * R l o g i n客户进程键入的信息将传输到服务器进程。但是有些时候，并不需要把键入的信息传输到服务器
  而是要和 R l o g i n客户进程直接通信。方法是在一行的开头键入代字符( t i l d e )“~”，紧跟着是下列4个字符之一：
  1. 以一个句号结束客户进程。
  2. 以文件结束符（通常是C o n t r o l _ D）结束客户进程。
  3. 以任务控制挂起符（通常是C o n t r o l _ Z）挂起客户进程。
  4. 以任务控制延迟挂起符（通常是 C o n t r o l _ Y）来挂起仅仅是客户进程的输入。
  * 不管客户运行什么程序，键入的任何信息将由该程序进行解释，但是从服务器发送到客户的信
息还是输出到终端上。这非常适合当我们需要在服务器上运行一个长时间程序的场合，程序的输出结果，同时还想在客户上运行其他程序。
只有当客户进程的U n i x系统支持任务控制时，后两个命令才有效。

* Rlogin会话建立的时，客户和服务器的协议交互
  * 主机b s d i到服务器s v r 4的R l o g i n建立一个连接时的时间系列 (在图中，去
掉了通常的T C P连接的建立
  * 客户发送一个字节的 0（报文段1）之后发送3个
字符串（报文段 3）。在本例中，这 3个字符串分别是： r s t e v e n s（客户的登录名）、r s t e v e n s
（服务器的登录名）和i b m p c 3 / 9 6 0 0（终端类型和速率）。当服务器确认了这些信息后回送一个
字节的0（报文段5）。
  * 服务器发送窗口请求命令（报文段 7）。这是采用T C P紧急方式发送的，实现( S V R 4 )采用较老的但更普通的解释，
  即紧急指针指明的序号是紧急数据的最后一个字节加1。客户回送1 2字节的数据：2字节的0 x ff，2字节的‘s’，4个16 bit长度的窗口数据。
下面的4个报文段（ 10, 12, 14和1 6）是由服务器发送的，是从服务器操作系统的问候( g r e e t i n g )。之后报文段1 8是一个7字节长度的外壳进程提示符“s v r 4％”。
  * 每次发送一个字节。客户和服务器都可以主动中断该连
接。如果我们输入一个命令，让服务器的外壳程序终止运行，那么服务器将中断该连接。如
果我们给R l o g i n客户键入一个转移符（通常是一个“ ~”），紧跟着一个句点或者是一个文件结
束符号，那么客户将主动关闭该连接。


* 客户中断键
  1. 键入C o n t r o l _ S以停止终端的输出。
  2. 用户终端的输出缓存很快被填满，所以 R l o g i n的客户向终端的写操作被阻塞。
  3. 此时客户也不能从网络连接上读取数据，所以客户的 T C P接收缓存也将被填满。
  4. 当接收缓存已满时，客户进程的T C P会向服务器进程的T C P通告现在的接收窗口是0。
  5. 当服务器收到客户的窗口为0时，将停止向客户发送数据，这样，服务器的发送缓存也将被填满。
  6.由于发送缓存已满，所以R l o g i n服务器进程将停止。这样，Rlogin服务器将不能从服务器运行的应用程序（c a t）处读取数据。
  7. 当c a t程序的输出缓存也被填满时，c a t也将停止。
  8. 然后我们用中断键来终止服务器上的 c a t程序。这个命令从客户的 TCP传输到服务器的T C P，这是因为该方向的数据传输没有被流量控制所终止。
  9. c a t应用程序收到中断命令并且终止。这使得它的输出缓存（也就是 Rlogin服务器进程
读取数据的地方）被清空，这将唤醒Rlogin服务器进程。然后Rlogin服务器进程进入紧急方式，
向客户进程发送“清仓输出”命令（0x02）

