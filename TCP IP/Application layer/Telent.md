 # Telnet和Rlogin：远程登录
 > 远程登录（Remote Login）是I n t e r n e t上最广泛的应用之一。我们可以先登录（即注册）
到一台主机然后再通过网络远程登录到任何其他一台网络主机上去，而不需要为每一台主机
连接一个硬件终端（当然必须有登录帐号）。

* T C P / I P网络上，有两种应用提供远程登录功能。
  1. Te l n e t是标准的提供远程登录功能的应用，几乎每个 T C P / I P的实现都提供这个功能。它
能够运行在不同操作系统的主机之间。Te l n e t通过客户进程和服务器进程之间的选项协商机制，
从而确定通信双方可以提供的功能特性。
  2. Rlogin起源于伯克利Unix，开始它只能工作在Unix系统之间，现在已经可以在其他操作系统上运行。
  3. 仅仅使用了一条T C P连接。由于客户进程必须多次和服务器进程进行通信（反之亦然），
这就必然需要某些方法，来描绘在连接上传输的命令和用户数据。我们在后面的内容中会介
绍Te l n e t和R l o g i n是如何处理这个问题的。
  4. 终端驱动进程和伪终端驱动进程框了起来在T C P / I P实现中，虚线框的内容一般是操作系统内核的一部分。
Te l n e t客户进程和服务器进程一般只是属于用户应用程序。
  5. 把服务器进程的登录外壳进程画出来的目的是为了说明：当我们想登录到系统的时候，必须要有一个帐号，Te l n e t和R l o g i n都是如此。

* Rlogin协议
  * RFC 1282 [Kantor 1991]详细说明了R l o g i n协议。类似于选路信息协议（R I P）的RFC
 R l o g i n用了许多年后才发布的。 [Stevens 1990]的第1 5章介绍了远程登录的客户进程及服务
器进程端的编程，并且给出了 R l o g i n的客户进程及服务器进程的完整源代码。
[ C o m e r和Stevens 1993]的第2 5章和第2 6章给出了Te l n e t的客户进程的实现细节和源代码。

* 应用进程的启动
  * R l o g i n的客户进程和服务器进程使用一个 T C P连接。当普通的T C P连接建立完毕之后，客
户进程和服务器进程之间将发生下面所述的动作
  1. 客户进程给服务器进程发送4个字符串：
  a. 一个字节的0；
  b. 用户登录进客户进程主机的登录名，以一个字节的0结束；
  c. 登录服务器进程端主机的登录名，以一个字节的0结束；
  d. 用户终端类型名，紧跟一个正斜杠“/”，然后是终端速率，以一个字节的0结束。在这里需要两个登录名字，这是因为用户登录客户和服务器的名称有可能不一样。由于大多满屏应用程序需要知道终端类型，所以终端类型也必须发送到服务器进程发送终端速率的原因是因为有些应用随着速率的改变，它的操作也有所变化。例如 vi编辑器，当速率比较小的时候，它的工作窗口也变小。所以它不能永远保持同样大小的窗口。
 2. 服务器进程返回一个字节的0。
 3. 服务器进程可以选择是否要求用户输入口令。这个步骤的数据交互没有什么特别的协议，而被当作是普通的数据进行传输。
  服务器进程给客户进程发送一个字符串（显示在客户进程的屏幕上），通常是password: 。如果在一定的限定时间内（通常是 6 0秒）
客户进程没有输入口令，服务器进程将关闭该连接。通常可以在服务器进程的主目录(home directory)下生成一个文件（通常叫 . r h o s t s），该
文件的某些行记录了一个主机名和用户名。如果从该文件中已经记录的主机上用已经记录的用户名进行登录，服务器进程将不提示我们输入口令。但是很多关于安全性的
文献，如[Curry 1992]，强烈建议不要采用这种方法，因为这存在安全漏洞。
  * 如果提示输入口令，那么我们输入的口令将以明文的形式发送到服务器进程键入的每个字符都是以明文的格式传输的。所以某人只要能够截取网络上的原始传输的分组，他就可以截获用户口令。针对这个问题，新版本的 Rlogin客户程序，例如4 . 4 B S D版本的客户程序，第一次采用了 Kerberos安全模型。Kerberos安全模型可以避免用户口令以明文的形式在网络上传输。当然，这要求服务器进程也支持 K e r b e r o s（[Curry 1992]详细描述了Kerber os安全模型）。
  4. 服务器进程通常要给客户进程发送请求，询问终端的窗口大小客户进程每次给服务器进程发送一个字节的内容，并且接收服务器进程的所有返回信息。
同样我们也采用了Nagle算法该算法可以保证在速率较低的网络上，若干输入字节以单个 T C P报文段传输。操作其实很简单：用户
键入的所有东西被发送到服务器，服务器发送给客户的任何信息返回到用户的屏幕上。
服务器和客户之间还可以互相发送命令。
  
* 流量控制
  * 默认情况下，流量控制是由 Rlogin的客户进程完成的。客户进程能够识别用户键入的
STOP和START的ASCII字符（C o n t r o l ＿ S和Control＿ Q），并且终止或启动终端的输出。
  * 如果不是这样，每次我们为终止终端输出而键入的 C o n t r o l _ S字符将沿网络传输到服务器
进程，这时服务器进程将停止往网络上写数据。但是在写操作终止之前，服务器进程可能已
经往网络上写了一窗口的输出数据。也就是说，在输出停止之前，成千上万的数据字节还将
对于一个交互式用户来讲，Control_S字符的响应延时是较大的。
  * 服务器的应用程序需要解释输入的每个字节，但又不想让客户对它的输入内容进行处理
  例如对控制字符如 Control_S和Control _ Q进行特殊处理（emacs编辑器就是这样的一个例子，它把Control _ S和Control _ C作为自己的命令）解决这个问题的办法就是由服务器告诉客户是否要进行流量控制


* 客户的中断键
  * 中断服务器正在运行的进程而键入一个中断字符时（通常是 D E L E T E或C o n t r o l _ C）
  会发生和流量控制相同的问题,在一条T C P连接的管道上，从服务器进程向客户进程正在发送大量的数据
  而客户进程同时在向服务器进程传输中断字符。而我们的本意是要中断字符尽快终止某个进程，使屏幕上不再有任何响应输出。
  * 在流量控制和中断键这两种情况中，流量控制机制很少终止客户进程到服务器进程的数据流。仅仅包含我们键入的字符。所以对于从客户输出到服务器的特殊输入字符（C o n t r o l _ S和中断字符）不需要采用T C P的紧急方式（u rgent mode）。


* 窗口大小的改变
  * 当应用程序在运行的时候，我们还可以动态地改变窗口的大小。
  一些应用程序（典型的如那些操作整个窗口的应用程序，如全屏编辑器）需要知道窗口大小的变化，
  多数U n i x系统提供这种功能，可以告诉应用程序关于窗口大小的变化。
  * 对于远程登录这种情况，窗口大小的变化发生在客户端，而运行在服务器端的应用程序
  需要知道窗口大小变化。所以 R l o g i n的客户需要采用某些方法来通知服务器窗口大小变化的情况以及新窗口的大小

* 服务器到客户的命令
  * R l o g i n服务器进程可以发送给客户进程的 4条命令。当只有一条T C P连接可供使用，所以服务器进程必须给这些命令字节做标记
  使得客户进程可以从数据流中识别出这些是命令，而不是显示在终端上。将使用 TCP的紧急方式
  * 当服务器要给客户发送命令时，服务器就进入紧急方式，并且把命令放在紧急数据的最后一个字节中。
  当客户进程收到这个紧急方式通知时，它从连接上读取数据并且保存起来，直到读到命令字节（即紧急数据的最后一个字节）。
  客户进程根据读到的命令，再决定对于所读到并保存起来的数据是显示在终端上还是丢弃它。
  * 采用T C P紧急方式发送这些命令的一个原因是第一个命令（“清仓输出(flush output)”）需要立即发送给客户
  即使服务器到客户的数据流被窗口流量控制所终止。这种情况下，即服


* 客户的转义符
  * R l o g i n客户进程键入的信息将传输到服务器进程。但是有些时候，并不需要把键入的信息传输到服务器
  而是要和 R l o g i n客户进程直接通信。方法是在一行的开头键入代字符( t i l d e )“~”，紧跟着是下列4个字符之一：
  1. 以一个句号结束客户进程。
  2. 以文件结束符（通常是C o n t r o l _ D）结束客户进程。
  3. 以任务控制挂起符（通常是C o n t r o l _ Z）挂起客户进程。
  4. 以任务控制延迟挂起符（通常是 C o n t r o l _ Y）来挂起仅仅是客户进程的输入。
  * 不管客户运行什么程序，键入的任何信息将由该程序进行解释，但是从服务器发送到客户的信
息还是输出到终端上。这非常适合当我们需要在服务器上运行一个长时间程序的场合，程序的输出结果，同时还想在客户上运行其他程序。
只有当客户进程的U n i x系统支持任务控制时，后两个命令才有效。

* Rlogin会话建立的时，客户和服务器的协议交互
  * 主机b s d i到服务器s v r 4的R l o g i n建立一个连接时的时间系列 (在图中，去
掉了通常的T C P连接的建立
  * 客户发送一个字节的 0（报文段1）之后发送3个
字符串（报文段 3）。在本例中，这 3个字符串分别是： r s t e v e n s（客户的登录名）、r s t e v e n s
（服务器的登录名）和i b m p c 3 / 9 6 0 0（终端类型和速率）。当服务器确认了这些信息后回送一个
字节的0（报文段5）。
  * 服务器发送窗口请求命令（报文段 7）。这是采用T C P紧急方式发送的，实现( S V R 4 )采用较老的但更普通的解释，
  即紧急指针指明的序号是紧急数据的最后一个字节加1。客户回送1 2字节的数据：2字节的0 x ff，2字节的‘s’，4个16 bit长度的窗口数据。
下面的4个报文段（ 10, 12, 14和1 6）是由服务器发送的，是从服务器操作系统的问候( g r e e t i n g )。之后报文段1 8是一个7字节长度的外壳进程提示符“s v r 4％”。
  * 每次发送一个字节。客户和服务器都可以主动中断该连
接。如果我们输入一个命令，让服务器的外壳程序终止运行，那么服务器将中断该连接。如
果我们给R l o g i n客户键入一个转移符（通常是一个“ ~”），紧跟着一个句点或者是一个文件结
束符号，那么客户将主动关闭该连接。


* 客户中断键
  1. 键入C o n t r o l _ S以停止终端的输出。
  2. 用户终端的输出缓存很快被填满，所以 R l o g i n的客户向终端的写操作被阻塞。
  3. 此时客户也不能从网络连接上读取数据，所以客户的 T C P接收缓存也将被填满。
  4. 当接收缓存已满时，客户进程的T C P会向服务器进程的T C P通告现在的接收窗口是0。
  5. 当服务器收到客户的窗口为0时，将停止向客户发送数据，这样，服务器的发送缓存也将被填满。
  6.由于发送缓存已满，所以R l o g i n服务器进程将停止。这样，Rlogin服务器将不能从服务器运行的应用程序（c a t）处读取数据。
  7. 当c a t程序的输出缓存也被填满时，c a t也将停止。
  8. 然后我们用中断键来终止服务器上的 c a t程序。这个命令从客户的 TCP传输到服务器的T C P，这是因为该方向的数据传输没有被流量控制所终止。
  9. c a t应用程序收到中断命令并且终止。这使得它的输出缓存（也就是 Rlogin服务器进程
读取数据的地方）被清空，这将唤醒Rlogin服务器进程。然后Rlogin服务器进程进入紧急方式，
向客户进程发送“清仓输出”命令（0x02）


* Telnet命令
 * Te l n e t通信的两个方向都采用带内信令方式。字节 0 x ff（十进制的 2 5 5）叫做IAC（interpret as command，意思是“作为命令来解释”）。该字节后面的一个字节才是命令字节。
 * 如果要发送数据2 5 5，就必须发送两个连续的字节 2 5 5（在前面一节中我们讲到数据流是 N V TA S C I I，它们都是 7 b i t的格式，这就暗示着 2 5 5这个数据字节不能在 Te l n e t上传输。其实在Telnet中有一个二进制选项，在 R F C 8 5 6 [ P o s t e l和Reynolds 1983b]中有定义该选项允许数据以8 b i t进行传输）。
 
 
* 选项协商
  * 虽然我们可以认为Te l n e t连接的双方都是N V T，但是实际上Te l n e t连接双方首先进行交互
的信息是选项协商数据。选项协商是对称的，也就是说任何一方都可以主动发送选项协商请求给对方。
对于任何给定的选项，连接的任何一方都可以发送下面 4种请求的任意一个请求。
  1. WILL： 发 送 方 本 身 将 激 活( e n a b l e )选项。
  2. DO：发送方想叫接收端激活选项。
  3. WONT：发送方本身想禁止选项。 
  4. DON’T：发送方想让接收端去禁止选项。
  * 由于Te l n e t规则规定，对于激活选项请求（如1和2），有权同意或者不同意。而对于使选项失效请求（如 3和4），必须同意。这
样，4种请求就会组合出6种情况选项协商需要3个字节：一个I A C字节，接着一个字节是 WILL, DO, WONT和D O N T这四者之一，最后一个I D字节指明激活或禁止选项。现在，有4 0多个选项是可以协商的。Assigned Number RFC文档中指明选项字节的值，并且一些相关的 R F C文档描述了这些选项。Te l n e t的选项协商机制和Te l n e t协议的大部分内容一样，是对称的。连接的双方都可以发起选项协商请求。但我们知道，远程登录不是对称的应用。客户进程完成某些任务，而服务器进程则完成其他一些任务。某些Te l n e t选项仅仅适合于客户进程（例如要求激活行模式方式），某些选项则仅仅适合于服务器进程。

* 子选项协商
  * 有些选项不是仅仅用“激活”或“禁止”就能够表达的。指定终端类型就是一个例子，客户进程必须发送用一个A S C I I字符串来表示终端类型。为了处理这种选项，我们必须定义子选项协商机制。
  * 在R F C 1 0 9 1 [ VanBokkelen 1989]中定义了如何表示终端类型这样的子选项协商机制。首先连接的某一方（通常是客户进程）发送 3个字节的字符序列来请求激活该选项。
  * <IAC, WILL, 24>
这里的2 4（十进制）是终端类型选项的 I D号。如果收端（通常是服务器进程）同意，那么响应数据是：
  * <IAC, DO, 24>
 然后服务器进程再发送如下的字符串：
  * <IAC, SB, 24, 1, IAC, SE>
该字符串询问客户进程的终端类型。其中 S B是子选项协商的起始命令标志。下一个字节
的“2 4”代表这是终端类型选项的子选项（通常S B后面的选项值就是子选项所要提交的内容）。
下一个字节的“ 1”表示“发送你的终端类型”。子选项协商的结束命令标志也是 I A C，就像
S B是起始命令标志一样。如果终端类型是 i b m p c，客户进程的响应命令将是：
  * ＜IAC, SB, 24, 0‘I’, ‘B’, ‘M’, ‘P’, ‘C’, IAC, SE＞
第4个字节“0”代表“我的终端类型是”（在Assigned Numbers RFC文档中有正式的关于
终端类型的数值定义，但是最起码在 U n i x系统之间，终端类型可以用任何对方可理解的数据进行表示。只要这些数据在 t e r m c a p或t e r m i n f o数据库中有定义）。在Te l n e t子选项协商过程中，
终端类型用大写表示，当服务器收到该字符串后会自动转换为小写字符

* 半双工、一次一字符、一次一行或行方式
  * 对于大多数Te l n e t的服务器进程和客户进程，共有4种操作方式。
1. 半双工\Te l n e t的默认方式，但现在却很少使用。 N V T默认是一个半双工设备，在接收用户输
入之前，它必须从服务器进程获得 GO AHEAD（G A）命令。用户的输入在本地回显，方向是
从N V T键盘到N V T打印机，所以客户进程到服务器进程只能发送整行的数据。
虽然该方式适用于所有类型的终端设备，但是它不能充分发挥目前大量使用的支持全双
工通信的终端功能。RFC 857 [Postel 和Reynolds 1983c]定义了E C H O选项，RFC 858 [Postel
和Reynolds 1983d]定义了SUPPRESS GO AHEAD（抑制继续进行）选项。如果联合使用这两
个选项，就可以支持下面将讨论的方式：带远程回显的一次一个字符的方式。
2. 一次一个字符方式
这和前面的R l o g i n工作方式类似。我们所键入的每个字符都单独发送到服务器进程。服务
器进程回显大多数的字符，除非服务器进程端的应用程序去掉了回显功能。
该方式的缺点也是显而易见的。当网络速度很慢，而且网络流量比较大的时候，那么回
显的速度也会很慢。虽然如此，但目前大多数 Te l n e t实现都把这种方式作为默认方式。
我们将看到，如果要进入这种方式，只要激活服务器进程的 SUPPRESS GO AHEAD选项
即可。这可以通过由客户进程发送 DO SUPPRESS GO AHEAD（请求激活服务器进程的选项）
请求完成，也可以通过服务器进程给客户进程发送 WILL SUPPRESS GO AHEAD（服务器进
程激活选项）请求来完成。服务器进程通常还会跟着发送 WILL ECHO，以使回显功能有效。
3. 一次一行方式
该方式通常叫做准行方式（kludge line mode），该方式的实现是遵照RFC 858的。该R F C
规定：如果要实现带远程回显的一次一个字符方式， E C H O选项和SUPPRESS GO AHEAD选
项必须同时有效。准行方式采用这种方式来表示当两个选项的其中之一无效时， Te l n e t就是工
作在一次一行方式。在下节中我们将介绍一个例子，可以看到如何协商进入该方式，并且当
程序需要接收每个击键时如何使该方式失效。
4. 行方式
我们用这个术语代表实行方式选项，这是在 RFC 1184[Borman 1990]中定义的。这个选项
也是通过客户进程和服务器进程进行协商而确定的，它纠正了准行方式的所有缺陷。目前比
较新的Te l n e t实现支持这种方式。
图2 6 - 11是不同的Te l n e t客户进程和服务器进程之间默认的操作方式。“c h a r”表示一次一
个字符方式，“k l u d g e”表示准行方式，“l i n e m o d e”表示如RFC 11 8 4定义的实行方式。

* Telnet举例
  * 三种不同的操作方式下 Te l n e t选项协商的情况。这些方式包括：单字符方式、实行方式和准行方式。同样我们还将讨论当用户在服务器端按了中断键退出了一个正在运行的进程后，系统的运行情况。

* 单字符方式
  * 该方式类似于 R l o g i n。用户在终端输入的每个字符都将由终端发送到服务器进程，服务器进程的响应也将以字符方式回显到终端上。在这里运行的是一
个新的客户进程B S D / 3 8 6，它试图激活很多新的选项，服务器进程还是运行老的 S V R 4，多选项被服务器拒绝。
为了看到服务器和客户机之间选项协商的内容，将激活客户进程的一个选项来显示
所有的选项协商。同样我们运行 t c p d u m p来获得数据报交换的时间次序。图 2 6 - 1 2显示了这个交互会话。
  * 在图中，由 S E N T或R C V D开头的选项协商的每一步都进行了标注。关于每一步的解释如下：
  1. 客户发起SUPPRESS GO AHEAD选项协商。由于GO AHEAD命令通常是由服务器发送给客户的，而且客户希望服务器激活该选项，因此该选项的请求方式是 D O（由于激活这一选项将会禁止G A命令的发送，上述过程很容易让人混淆）。在第1 0行可以看到服务器进程同意该选项。
  2. 客户进程要按照在RFC 1091[VanBokkelen 1989]中的定义发送终端类型。这对U n i x类型的
客户进程来讲是很普通的。因为客户进程要激活本地的选项，所以该选项的请求方式是W I L L。
  3. NAW S的意思是“协商窗口大小”，它在RFC 1073 [Waitzman]中有定义。如果服务器
进程同意该选项，客户进程就要发送终端窗口的行、列大小的子选项。而且只要窗口大小发生变化，客户进程随时都将向服务器进程发送这一子选项（这和图2 6 - 4中Rlogin的0 x 8 0命令类似）。
  4. TSPEED 选项允许发送方（通常是客户进程）发送它的终端速率，这在 RFC 1079
[Hedrick 1988b]中有定义。如果服务器进程同意（实际上不同意，见 1 2行），客户进程将发送其发送速率和接收速率的子选项。
  5. LFLOW代0表“本地流量控制”，这在RFC1371 [Hedrick 和Borman 1992]中定义
  客户进程给服务器进程发送该选项，表示客户进程希望用命令方式激活或禁止流量控制。
服务器进程同意，只要C o n t r o l _ S和C o n t r o l _ Q进程需要在客户进程和
服务器进程进行切换，客户进程都要向服务器进程发送子选项（这类似于图 2 6 - 4中R l o g i n的0 x 1 0和0 x 2 0命令）由客户进程进行流量控制的效果比由服务器进程来完成要好。
  6. LINEMODE代表在26.4中所说的实行方式。所有终端字符的处理由 Telnet客户进程完成（例如回格，删除行等），然后整行发送给服务器进程。
  7. ENVIRON选项允许客户进程把环境变量发送给服务器进程，这在 RFC 1408 [Borman1 9 9 3 a ]中有定义。这样就可以把客户进程的用户环境变量自动传播到服务器进程。15行，服务器进程拒绝该选项（ U n i x中的环境变量通常是大写字母，紧跟一个等号，然后是一个字符串值，当然这只是一个惯例而已）。默认情况下，BSD/386 Te l n e t客户进程发送两个环境变量：DISPLAY和PRINTER，前提是这两个变量已经定义并且有效。 Te l n e t用户可以定义其他一些发送的环境变量。
  8. STAT U S选项（RFC 859 [Postel 和Reynolds 1983e]中定义）允许连接的一方询问对方对Te l n e t选项目前状态的理解。在这个例子中，客户进程要求对方激活选项（ D O）。如果服务器进程同意（实际上不同意，见 1 6行），客户进程就可以要求服务器进程以子选项的形式发送它1的状态值。
  9. 这是服务器进程的第一个响应。服务器进程同意激活终端类型选项（几乎所有的 U n i x类型的服务器进程都支持该选项）。但现在客户进程还不能立即发送它的终端类型。它必须要等到服务器进程用子选项的形式询问终端类型的时候才能够发送（ 1 7行）。
  10. 服务器进程同意抑制发送GO AHEAD命令。
  11. 服务器进程不同意客户进程发送它的窗口大小。
  12. 服务器进程不同意客户进程发送它的终端速率。
  13. 服务器进程不同意客户进程实施流量控制。
  14. 服务器进程不同意客户进程激活行方式选项。
  15. 服务器进程不同意客户进程发送环境变量。
  16. 服务器进程不发送状态信息。
  17. 这是服务器进程要求客户进程发送终端类型的子选项。
  18. 客户进程把终端类型“I B M P C 3”以6字节的字符串形式发送给服务器进程。
  19. 服务器进程要求客户进程发起请求，要求服务器进程激活回显选项。
  20. 客户进程同意由服务器进程实现回显功能。
  21. 服务器进程要求客户进程实现回显功能。这个命令是多余的，它只是将前两行进行了
交换。这是目前大多数 U n i x的Te l n e t服务器进程判断客户进程是否运行 ,如果客户进程回送 WILL ECHO，就表明客户进程运行的是老版本的不支持T C P的紧急方式（在这种情况下就不能采用 T C P紧急方式）。
  22.  客户进程回送WONT ECHO，表示它不是一台4 . 2 B S D主机
  23. 对于客户进程回送的WONT ECHO，服务器进程以DONT ECHO作为响应。
图2 6 - 1 3显示的是本例中服务器进程和客户进程交互的时间系列（去掉了连接建立部分）。
报文段1包含了图2 6 - 1 2中的1 ~ 8行。该报文段中包含2 4个字节数据，每个选项占 3个字节。
这是客户进程发起的选项协商。该报文段显示多个 Te l n e t选项可以打在一个T C P段中发送。
报文段3是图2 6 - 1 2中的第9行，即DO TERMINAL TYPE命令。报文段5包含下面的8个选
项协商中服务器进程的响应，即图 2 6 - 1 2中的1 0 ~ 1 7行。该报文段的长度是 2 7个字节，因为
1 0 ~ 1 6行是常规选项，每个占 3个字节，而1 7行的子选项部分占6个字节。报文段6包含1 2个字
节，和1 8行对应，这是客户发送它的终端类型的子选项。

