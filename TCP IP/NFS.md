# NFS网络文件系统
> 它为客户程序提供透明的文件访问。N F S的基础是Sun RPC：远程过程调用。
 R P C:客户程序使用 N F S不需要做什么特别的工作，当 N F S内核检测到被访问的文件位于一个N F S服务器时，
 就会自动产生一个访问该文件的 R P C调用对它如何使用 I n t e r n e t的协议，尤其是U D P协议，

* Sun远程过程调用
  * 多数的网络程序设计都是编写一些调用系统提供的函数来完成特定的网络操作的应用程序。
  * 例如，一个函数完成 T C P的主动打开，另一个完成 T C P的被动打开，一个函数在一个T C P连接上发送数据，另一个设置特定的协议选项（如激活 T C P的k e e p a l i v e定时器）两个常用的用于网络编程的函数集（ A P I）：插口( s o c k e t )和T L I。正像客户端和服务器端运行的操作系统可能会不相同一样，双方使用的 A P I也可能会不相同。
  * 由通信协议和应用协议决定一对客户和服务器是否可以彼此通信。如果两台主机连接在一个网络上，并且都有一个T C P / I P的实现，那么一台主机上的一个使用C语言编写的、使用插口和T C P的U n i x客户程序可以和另一台主机上的一个使用 C O B O L语言编写的、使用其他 A P I和T C P的大型机服务器进行通信。
  * 客户发送命令给服务器，服务器向客户发送应答所有应用程序 — Ping，Traceroute，选路守护程序、以及 DNS、TFTP、BOOTP、SNMP、Telnet、FTP和SMTP的客户和服务器 — 都是采用这种方式实现的。远程过程调用RPC (Remote Procedure Call)是一种不同的网络程序设计方法。客户程序编写时只是调用了服务器程序提供的函数。这只是程序员所感觉到的，实际上发生了下面一些动作。
  1. 当客户程序调用远程的过程时，它实际上只是调用了一个位于本机上的、由 R P C程序包生成的函数这个函数被称为客户残桩（stub）客户残桩将过程的参数封装成一个网络报文，并且将这个报文发送给服务器程序。
  2. 服务器主机上的一个服务器残桩负责接收这个网络报文。它从网络报文中提取参数，然后调用应用程序员编写的服务器过程。
  3. 当服务器函数返回时，它返回到服务器残桩。服务器残桩提取返回值，把返回值封装成一个网络报文，然后将报文发送给客户残桩。
  4. 客户残桩从接收到的网络报文中取出返回值，将其返回给客户程序。
网络程序设计是通过残桩和使用诸如插口或 T L I的某个A P I的R P C库例程来实现的，但是
用户程序 — 客户程序和被客户程序调用的服务器过程 — 不会和这个A P I打交道。客户应用
程序只是调用服务器的过程，所有网络程序设计的细节都被 R P C程序包、客户残桩和服务器残桩所隐藏。

* 一个R P C程序包提供的好处
  1. 程序设计更加容易，因为很少或几乎没有涉及网络编程。应用程序设计员只需要编写一个客户程序和客户程序调用的服务器过程。
  2. 如果使用了一个不可靠的协议，如 U D P，像超时和重传等细节就由 R P C程序包来处理。这就简化了用户应用程序。
  3. RPC库为参数和返回值的传输提供任何需要的数据转换。例如，如果参数是由整数和浮点数组成的，R P C程序包处理整数和浮点数在客户机和服务器主机上存储的不同形式。这个功能简化了在异构环境中的客户和服务器的编码问题。
  * R P C程序设计的细节可以参看参考文献 [Stevens 1990]的第1 8章。两个常用的R P C程序包是Sun RPC和开放软件基金（O S F）分布式计算环境（DCE）的R P C程序包。对于R P C的兴趣在于想了解Sun RPC中过程调用和过程返回报文的形式，因为本章中讨论的网络文件系统使用了它们。Sun RPC的第2版定义在RFC 1057 [Sun Microsystems 1988a]中。

* Sun RPC
  * Sun RPC有两个版本。一个版本建立在插口A P I基础上，和T C P和U D P打交道
  * 另一个称为 T I - R P C的（独立于运输层），建立在TLI API基础上，可以和内核提供的任何运输层协议打交道。
  * T C P和U D P，来说两者是一样的。

* XDR: 外部数据表示
  * 外部数据表示XDR (eXternal Data Representation)是一个标准，用来对R P C调用报文和应
答报文中的值进行编码。这些值包括 R P C首部字段（X I D、程序号、接受状态等）、过程参数和过程结果。
采用标准化的方法对这些值进行编码使得一个系统中的客户可以调用另一个不同架构的系统中的一个过程。
X D R在RFC 1014中定义[Sun Microsystems 1987]。
  * X D R定义了很多数据类型以及它们如何在一个 R P C报文中传输的具体形式（如比特顺序，
字节顺序等）。发送者必须采用X D R格式构造一个R P C报文，然后接收者将X D R格式的报文转
换为本机的表示形式。例如，在图2 9 - 1和图2 9 - 2中，我们显示的所有整数值（X I D、调用字段、
程序号等）都是4字节的整数。在X D R中，所有的整数的确占据 4个字节。X D R支持的其他数
据类型包括无符号整数、布尔类型、浮点数、定长数组、可变长数组和结构。

* 端口映射器
  * 远程过程的R P C服务器程序使用的是临时端口，而不是知名端口。这就需要某种形
式的“注册”程序来跟踪哪一个R P C程序使用了哪一个临时端口。在Sun RPC中，这个注册程序被称为端口映射器(port mapper)。
  * “端口”这个词作为Internet协议族的一个特征，来自于T C P和U D P端口号。既然TI-RPC可以工作在任何运输层协议之上
 而不仅仅是 T C P和U D P，所以使用T I - R P C的系统中（如S V R 4和Solaris 2.2）端口映射器的名字变成了r p c b i n d。
很自然地，端口映射器本身必须有一个知名端口： U D P端口111和T C P端口111。
  * 端口映射器也就是一个R P C服务器程序。它有一个程序号（ 1 0 0 0 0 0）、一个版本号（2）、一个T C P端口111和一个U D P端口111。服务器程序使用 R P C调用向端口映射器注册自身，客户程序使用R P C调用向端口映射器查询。
  
* 端口映射器提供四个服务过程：
  1. PMAPPROC_SET。一个R P C服务器启动时调用这个过程，注册一个程序号、版本号和
带有一个端口号的协议。
  2. PMAPPROC_UNSET。R P C服务器调用此过程来删除一个已经注册的映射。
  3. PMAPPROC_GETPORT。一个R P C客户启动时调用此过程。根据一个给定的程序号、
版本号和协议来获得注册的端口号。
  4. PMAPPROC_DUMP。返回端口映射器数据库中所有的记录（每个记录包括程序号、版本号、协议和端口号）：
  

* R P C服务器程序启动，接着被一个 R P C客户程序调用的过程中，进行了以下一些步骤：
  1. 一般情况下，当系统引导时，端口映射器必须首先启动。它创建一个 T C P端点，并且被
动打开T C P端口111。它也创建一个U D P端点，并且在U D P端口111等待着U D P数据报的到来。
  2. 当R P C服务器程序启动时，它为它所支持的程序的每一个版本创建一个 T C P端点和一
个U D P端点（一个给定的 R P C程序可以支持多个版本。客户调用一个服务器过程时，说明它
想要哪一个版本）。两个端点各自绑定一个临时端口（ T C P端口号和U D P端口号是否一致无关
紧要）。服务器通过R P C调用端口映射器的 P M A P P R O C _ S E T过程，注册每一个程序、版本、
协议和端口号。
  3. 当R P C客户程序启动时，它调用端口映射器的 P M A P P R O C _ G E T P O RT过程来获得一个
指定程序、版本和协议的临时端口号。
  4. 客户发送一个R P C调用报文给第3步返回的端口号。如果使用的是 U D P，客户只是发送
一个包含R P C调用报文（见图 2 9 - 1）的U D P数据报到服务器相应的 U D P端口。服务器发送一
个包含R P C应答报文（见图2 9 - 2）的U D P数据报到客户作为响应。
  * 如果使用的是T C P，客户对服务器的T C P端口号做一个主动打开，然后在建立的 T C P连接
上发送一个R P C调用报文。服务器作为响应，在连接上发送一个 R P C应答报文。
安装守护程序（mount daemon）的两个版本可以通过同样的 T C P端口号（7 0 2）和同样的
U D P端口号（6 9 9）来访问，而加锁管理程序（ lock manager）的每个版本都有各自不同的端口号。


* NFS协议
使用N F S，客户可以透明地访问服务器上的文件和文件系统。这不同于提供文件传输的
F T P（第2 7章）。F T P会产生文件一个完整的副本。 N F S只访问一个进程引用文件的那一部分，
并且N F S的一个目的就是使得这种访问透明。这就意味着任何能够访问一个本地文件的客户
程序不需要做任何修改，就应该能够访问一个 N F S文件。
N F S是一个使用Sun RPC构造的客户服务器应用程序。 N F S客户通过向一个N F S服务器发
送R P C请求来访问其上的文件。尽管这一工作可以使用一般的用户进程来实现 — 即N F S客
户可以是一个用户进程，对服务器进行显式调用。而服务器也可以是一个用户进程 — 因为
两个理由，N F S一般不这样实现。首先，访问一个 N F S文件必须对客户透明。因此， N F S的客
户调用是由客户操作系统代表用户进程来完成的。第二，出于效率的考虑， N F S服务器在服
务器操作系统中实现。如果 N F S服务器是一个用户进程，每个客户请求和服务器应答（包括
读和写的数据）将不得不在内核和用户进程之间进行切换，这个代价太大。
本节中，我们考察在R F C 1 0 9 4中说明的第2版的NFS [Sun Microsystems 1988b]。[ X / O p e n
1991] 中给出了Sun RPC、X D R和N F S的一个更好的描述。 [Stern 1991] 给出了使用和管理
N F S的细节。第3版的N F S协议在1 9 9 3年发布，我们在2 9 . 7节中对它做一个简单的描述。
图2 9 - 3显示了一个N F S客户和一个N F S服务器的典型配置，图中有很多地方需要注意。
1) 访问的是一个本地文件还是一个 N F S文件对于客户来说是透明的。当文件被打开时，
由内核决定这一点。文件被打开之后，内核将本地文件的所有引用传递给名为“本地文件访
问”的框中，而将一个N F S文件的所有引用传递给名为“N F S客户”的框中。
2) NFS客户通过它的T C P / I P模块向N F S服务器发送R P C请求。N F S主要使用U D P，最新的
实现也可以使用T C P。
3) NFS服务器在端口2 0 4 9接收作为U D P数据报的客户请求。尽管 N F S可以被实现成使用
端口映射器，允许服务器使用一个临时端口，但是大多数的实现都是直接指定 U D P端口2 0 4 9。
4) 当N F S服务器收到一个客户请求时，它将这个请求传递给本地文件访问例程，后者访
问服务器主机上的一个本地的磁盘文件。
5) NFS服务器需要花一定的时间来处理一个客户的请求。访问本地文件系统一般也需要
一部分时间。在这段时间间隔内，服务器不应该阻止其他的客户请求得到服务。为了实现这
一功能，大多数的N F S服务器都是多线程的 — 即服务器的内核中实际上有多个 N F S服务器在
6) 同样，在客户主机上， N F S客户需要花一定的时间来处理一个用户进程的请求。 N F S
客户向服务器主机发出一个 R P C调用，然后等待服务器的应答。为了给使用 N F S的客户主机
上的用户进程提供更多的并发性，在客户内核中一般运行着多个 N F S客户。同样，具体实现
也依赖于操作系统。U n i x系统经常使用类似于N F S服务器的技术：一个叫作b i o d的用户进程执
行一个系统调用，作为一个内核进程保留在操作系统的内核中。

 



